{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { getBusinessInfo, compressImage, checkItemAvailability } from './storageService';\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\nconst SHARED_MENU_STORE = 'sharedMenus';\nconst IMAGE_STORE = 'menuImages';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = event => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n\n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        if (!existingStores.includes(SHARED_MENU_STORE)) {\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\n          return;\n        }\n        resolve(db);\n      };\n      request.onupgradeneeded = event => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n\n        // Crear almacén para menús compartidos si no existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.log('Creando almacén:', SHARED_MENU_STORE);\n          db.createObjectStore(SHARED_MENU_STORE, {\n            keyPath: 'id'\n          });\n        }\n\n        // Crear almacén para imágenes si no existe\n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('Creando almacén:', IMAGE_STORE);\n          db.createObjectStore(IMAGE_STORE, {\n            keyPath: 'id'\n          });\n        }\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n/**\n * Genera un ID único para un menú\n * @returns {string} Un ID único\n */\nfunction generateMenuId() {\n  return Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n}\n\n/**\n * Guarda un menú compartido y devuelve su ID\n * @param {Array} menuItems - Elementos del menú a guardar\n * @returns {Promise<String>} - ID del menú compartido\n */\nexport async function saveMenu(menuItems) {\n  try {\n    // Generar un ID único para el menú compartido\n    const menuId = generateMenuId();\n\n    // Obtener información del negocio para incluirla en el menú compartido\n    const businessInfo = await getBusinessInfo();\n\n    // Preprocesar los elementos del menú - comprimir imágenes y normalizar isSpecial\n    const processedItems = await Promise.all(menuItems.map(async item => {\n      const processedItem = {\n        ...item\n      };\n      processedItem.isSpecial = Boolean(item.isSpecial);\n      console.log(`[saveMenu] Guardando ${item.name} con isSpecial=${processedItem.isSpecial}`);\n\n      // Comprimir la imagen si existe\n      if (processedItem.image && typeof processedItem.image === 'string' && processedItem.image.length > 0) {\n        try {\n          // Usar una calidad más baja para compartir\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\n        } catch (err) {\n          console.warn('Error al comprimir imagen:', err);\n          processedItem.image = null;\n        }\n      }\n      return processedItem;\n    }));\n\n    // Crear objeto del menú con información del negocio incluida\n    const menuData = {\n      id: menuId,\n      items: processedItems,\n      businessInfo: businessInfo,\n      // Incluir la información del negocio (con datos de pago)\n      createdAt: new Date().toISOString()\n    };\n\n    // Verificar tamaño del objeto\n    try {\n      const jsonSize = JSON.stringify(menuData).length / (1024 * 1024); // Tamaño en MB\n      console.log(`Tamaño del menú a guardar: ${jsonSize.toFixed(2)} MB`);\n      if (jsonSize > 50) {\n        throw new Error(`El menú es demasiado grande (${jsonSize.toFixed(2)} MB). Reduce el tamaño de las imágenes.`);\n      }\n    } catch (error) {\n      console.error('Error al verificar tamaño del menú:', error);\n      throw new Error('Error al verificar tamaño del menú');\n    }\n\n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      request.onsuccess = () => {\n        console.log(`Menú guardado exitosamente con ID: ${menuId}`);\n        resolve();\n      };\n      request.onerror = e => {\n        console.error('Error al guardar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n\n    // Añadir logs de depuración\n    console.log('[saveMenu] Items a guardar:', menuItems.length);\n    console.log('[saveMenu] Items especiales:', menuItems.filter(item => item.isSpecial).length);\n    console.log('[saveMenu] Items regulares:', menuItems.filter(item => !item.isSpecial).length);\n\n    // Sincronizar información del negocio con el backend\n    await syncBusinessInfoWithBackend();\n    return menuId;\n  } catch (error) {\n    console.error('Error al guardar el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene un menú compartido por su ID\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getSharedMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\n\n    // Verificar que tenemos un ID válido\n    if (!menuId) {\n      console.error('ID de menú no proporcionado');\n      return null;\n    }\n\n    // Implementación optimizada para priorizar datos en tiempo real con fallback local\n    let menuData = null;\n    let isOnline = navigator.onLine;\n    console.log(`Estado de conexión: ${isOnline ? 'Online' : 'Offline'}`);\n\n    // Función para verificar conexión real con ping al servidor\n    const checkRealConnection = async () => {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000);\n        const response = await fetch('/api/ping', {\n          signal: controller.signal,\n          cache: 'no-store',\n          headers: {\n            'Cache-Control': 'no-cache'\n          }\n        });\n        clearTimeout(timeoutId);\n        return response.ok;\n      } catch (e) {\n        console.log('Error al verificar conexión real:', e);\n        return false;\n      }\n    };\n\n    // Intentaremos primero cargar datos en caché mientras verificamos la conexión real\n    // (Patrón stale-while-revalidate)\n    try {\n      console.log('Intentando cargar menú desde caché mientras verificamos conexión...');\n      const menuUtils = await import('./menuUtils');\n      const cachedMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n\n      // Si tenemos un menú en caché, lo usamos temporalmente mientras obtenemos datos frescos\n      if (cachedMenu && cachedMenu.items && cachedMenu.items.length > 0) {\n        console.log('Menú en caché encontrado y listo para uso inmediato');\n        menuData = cachedMenu;\n        // Marcamos el menú como potencialmente obsoleto\n        menuData._fromCache = true;\n      }\n    } catch (cacheError) {\n      console.warn('No se pudo obtener menú en caché para uso inmediato:', cacheError);\n    }\n\n    // Si estamos online, intentamos obtener datos frescos del servidor\n    if (isOnline) {\n      console.log(`Obteniendo menú fresco desde el servidor con ID: ${menuId}`);\n      try {\n        // Comprobación real de conexión en paralelo\n        const realConnectionPromise = checkRealConnection();\n\n        // Importamos apiService usando import dinámico para evitar problemas de dependencia circular\n        const apiService = await import('./apiService');\n\n        // Verificamos si realmente tenemos conexión\n        const hasRealConnection = await realConnectionPromise;\n        if (!hasRealConnection) {\n          console.warn('Detectada conexión inestable o sin acceso al servidor');\n          isOnline = false;\n          // Si no tenemos conexión real pero tenemos datos en caché, usamos la caché\n          if (menuData) return menuData;\n          // De lo contrario, continuamos con el proceso de fallback\n          throw new Error('Sin conexión real al servidor');\n        }\n\n        // Hacemos la petición al servidor para obtener el menú con timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 8000);\n        const response = await Promise.race([apiService.default.get(`/platos/menu/${menuId}`, {\n          signal: controller.signal\n        }), new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout al obtener menú del servidor')), 8000))]);\n        clearTimeout(timeoutId);\n        if (response && response.success && response.data) {\n          console.log('Menú recuperado desde el servidor:', response.data);\n          menuData = response.data;\n          menuData._fromCache = false; // Marcamos como datos frescos\n\n          // Guardar en IndexedDB para tenerlo disponible offline\n          try {\n            const menuUtils = await import('./menuUtils');\n            await menuUtils.saveMenuToIndexedDB(menuId, menuData);\n            console.log('Menú guardado en IndexedDB correctamente');\n          } catch (saveError) {\n            console.warn('No se pudo guardar el menú en IndexedDB:', saveError);\n          }\n        } else {\n          console.warn('La respuesta del servidor no contiene datos válidos:', response);\n          // Si tenemos datos en caché y la respuesta del servidor es inválida, usamos la caché\n          if (menuData && menuData._fromCache) {\n            console.log('Usando datos en caché debido a respuesta inválida del servidor');\n            return menuData;\n          }\n          // Pasamos al fallback si no tenemos caché\n        }\n      } catch (serverError) {\n        console.error('Error al obtener el menú desde el servidor:', serverError);\n        // Si hay error de conexión pero tenemos datos en caché, usamos la caché\n        if (menuData && menuData._fromCache) {\n          console.log('Usando datos en caché debido a error del servidor');\n          return menuData;\n        }\n        // Si no hay caché, pasamos al fallback completo\n        isOnline = false;\n      }\n    }\n\n    // Si no pudimos obtener datos del servidor o estamos offline,\n    // intentamos recuperar desde IndexedDB como respaldo principal\n    if (!menuData) {\n      try {\n        console.log('Intentando recuperar menú desde IndexedDB...');\n        const menuUtils = await import('./menuUtils');\n        const localMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n        if (localMenu && localMenu.items && localMenu.items.length > 0) {\n          console.log('Menú recuperado desde IndexedDB:', localMenu);\n          menuData = localMenu;\n        } else {\n          console.warn('No se encontró el menú en IndexedDB o no contiene items');\n        }\n      } catch (localError) {\n        console.warn('No se pudo obtener el menú desde IndexedDB:', localError);\n      }\n\n      // Si tampoco hay datos en IndexedDB, intentamos recuperar de localStorage como último recurso\n      if (!menuData) {\n        try {\n          console.log('Intentando recuperar menú desde localStorage...');\n          const cachedMenu = localStorage.getItem(`menu_${menuId}`);\n          if (cachedMenu) {\n            menuData = JSON.parse(cachedMenu);\n            console.log('Menú recuperado desde localStorage:', menuData);\n          } else {\n            throw new Error('No se encontró el menú en ninguna caché');\n          }\n        } catch (cacheError) {\n          console.error('Error al recuperar menú desde la caché:', cacheError);\n          throw new Error('No se pudo obtener el menú de ninguna fuente');\n        }\n      }\n    }\n\n    // Si el menú no tiene información de negocio, intentar obtenerla\n    if (menuData && !menuData.businessInfo) {\n      try {\n        const businessInfo = await getBusinessInfo();\n        menuData.businessInfo = businessInfo;\n      } catch (businessError) {\n        console.warn('No se pudo obtener información del negocio:', businessError);\n        // Usar información por defecto si no se puede obtener\n        menuData.businessInfo = {\n          name: 'Restaurante WebSAP',\n          description: 'Deliciosa comida para todos los gustos',\n          contact: 'info@websap.com',\n          address: 'Calle Principal #123',\n          logo: null,\n          paymentInfo: {\n            qrImage: null,\n            qrTitle: 'Escanea para pagar',\n            nequiNumber: null,\n            nequiImage: null,\n            bankInfo: 'Banco XYZ - Cuenta 123456789',\n            otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n          }\n        };\n      }\n    }\n\n    // Asegurarse de que businessInfo siempre tenga un objeto paymentInfo\n    if (menuData && menuData.businessInfo && !menuData.businessInfo.paymentInfo) {\n      menuData.businessInfo.paymentInfo = {\n        qrImage: null,\n        qrTitle: 'Escanea para pagar',\n        nequiNumber: null,\n        nequiImage: null,\n        bankInfo: 'Banco XYZ - Cuenta 123456789',\n        otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n      };\n    }\n\n    // Guardar en localStorage para tener un respaldo\n    try {\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify(menuData));\n    } catch (saveError) {\n      console.warn('No se pudo guardar el menú en localStorage:', saveError);\n    }\n\n    // Añadir logs de depuración con verificaciones de seguridad\n    console.log('[getSharedMenu] Menú recuperado:', menuData);\n\n    // Usar el operador de encadenamiento opcional para evitar errores\n    const specialItems = menuData?.items?.filter(i => i.isSpecial) || [];\n    const regularItems = menuData?.items?.filter(i => !i.isSpecial) || [];\n    console.log('[getSharedMenu] Items especiales:', specialItems.length);\n    console.log('[getSharedMenu] Items regulares:', regularItems.length);\n    return menuData;\n  } catch (error) {\n    console.error('Error al obtener el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Alias para getSharedMenu para mantener compatibilidad con código existente\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getMenu(menuId) {\n  console.log('Intentando recuperar menú con ID:', menuId);\n  try {\n    const db = await openDatabase();\n    const tx = db.transaction('sharedMenus', 'readonly');\n    const store = tx.objectStore('sharedMenus');\n\n    // Obtener el menú de la base de datos\n    const request = store.get(menuId);\n    const result = await new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        console.log('Resultado de búsqueda del menú:', request.result);\n        resolve(request.result);\n      };\n      request.onerror = e => {\n        console.error('Error al recuperar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n\n    // Verificar si se encontró el menú\n    if (!result) {\n      console.warn(`No se encontró menú con ID: ${menuId}`);\n      return null;\n    }\n\n    // Verificar si el menú tiene items y es un array\n    if (result && result.items && Array.isArray(result.items)) {\n      console.log('[menuService] Procesando items en getMenu()');\n\n      // Procesar cada item para normalizar isSpecial\n      const processedItems = result.items.map(item => {\n        // Si isSpecial no existe, asignar false por defecto\n        if (item.isSpecial === undefined) {\n          console.log(`[menuService] Item ${item.name || 'sin nombre'} sin propiedad isSpecial, asignando false`);\n          return {\n            ...item,\n            isSpecial: false\n          };\n        }\n\n        // Normalizar isSpecial a un valor booleano\n        const normalizedIsSpecial = item.isSpecial === true || item.isSpecial === 'true' || item.isSpecial === 1 || item.isSpecial === '1';\n        if (typeof item.isSpecial !== 'boolean') {\n          console.log(`[menuService] Normalizando isSpecial para ${item.name}: ${item.isSpecial} (${typeof item.isSpecial}) → ${normalizedIsSpecial}`);\n        }\n        return {\n          ...item,\n          isSpecial: normalizedIsSpecial\n        };\n      });\n      console.log(`[menuService] Procesados ${processedItems.length} items:`, processedItems.map(i => ({\n        name: i.name,\n        isSpecial: i.isSpecial\n      })));\n\n      // Devolver el objeto completo con los items procesados\n      return {\n        ...result,\n        items: processedItems\n      }; // Devuelve el objeto completo con los items procesados\n    } else {\n      console.warn('El menú no tiene items o no es un array:', result);\n\n      // Si no tiene items, devolver el resultado tal cual\n      return result;\n    }\n  } catch (error) {\n    console.error('Error al obtener menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Guarda un menú compartido en IndexedDB\n * @param {Object} menuData - Datos del menú a guardar\n * @returns {Promise<void>}\n */\nexport async function saveSharedMenu(menuData) {\n  try {\n    if (!menuData || !menuData.id) {\n      throw new Error('Datos de menú inválidos');\n    }\n    console.log(`Guardando menú compartido con ID: ${menuData.id}`);\n\n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      request.onsuccess = () => {\n        console.log(`Menú compartido guardado exitosamente con ID: ${menuData.id}`);\n        resolve();\n      };\n      request.onerror = e => {\n        console.error('Error al guardar el menú compartido:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    console.log('[saveSharedMenu] Menú guardado en IndexedDB');\n  } catch (error) {\n    console.error('Error al guardar el menú compartido en IndexedDB:', error);\n    throw error;\n  }\n}\n\n/**\n * Limpia menús antiguos que ya no son necesarios\n * @returns {Promise<void>}\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      request.onerror = e => {\n        console.error('Error al obtener menús:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n\n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n    console.log(`Se eliminaron ${menusToDelete.length} menús antiguos`);\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n// Añadir después de getSharedMenu\nexport async function syncMenuAvailability(menuId) {\n  try {\n    const sharedMenu = await getSharedMenu(menuId);\n    if (!sharedMenu || !sharedMenu.items) return null;\n\n    // Actualizar la disponibilidad de cada item\n    const updatedItems = await Promise.all(sharedMenu.items.map(async item => {\n      const availability = await checkItemAvailability(item.id);\n      return {\n        ...item,\n        availableQuantity: availability.quantity\n      };\n    }));\n\n    // Actualizar el menú con las nuevas disponibilidades\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const updatedMenu = {\n      ...sharedMenu,\n      items: updatedItems,\n      lastSync: new Date().toISOString()\n    };\n    await store.put(updatedMenu);\n    return updatedMenu;\n  } catch (error) {\n    console.error('Error al sincronizar disponibilidad:', error);\n    return null;\n  }\n}\n\n/**\n * Sincroniza la información del negocio con el backend\n * @param {Object} businessInfo - Información del negocio a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend(businessInfo) {\n  try {\n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n\n    // Verificar que tenemos información válida\n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.error('No hay información del negocio para sincronizar');\n      return {\n        success: false,\n        message: 'No hay información del negocio para sincronizar'\n      };\n    }\n\n    // Importar apiService dinámicamente para evitar dependencias circulares\n    const apiServiceModule = await import('./apiService');\n    const apiService = apiServiceModule.default;\n\n    // Asegurarse de que el token esté configurado\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n\n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return {\n        success: false,\n        message: 'No se pudo obtener el restaurante del usuario actual'\n      };\n    }\n    const restauranteId = userResponse.user.restaurante_id;\n\n    // Asegurarse de que paymentInfo sea un objeto válido\n    const paymentInfo = businessInfo.paymentInfo || {\n      qrImage: null,\n      qrTitle: 'Escanea para pagar',\n      nequiNumber: null,\n      nequiImage: null,\n      bankInfo: 'Banco XYZ - Cuenta 123456789',\n      otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n    };\n\n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name || '',\n      descripcion: businessInfo.description || '',\n      direccion: businessInfo.address || '',\n      telefono: businessInfo.contact || '',\n      logo: businessInfo.logo || null,\n      informacion_pago: JSON.stringify(paymentInfo)\n    };\n    console.log('Datos a enviar al backend:', restauranteData);\n\n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      return {\n        success: true,\n        message: 'Información del negocio sincronizada con éxito'\n      };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return {\n        success: false,\n        message: response.message || 'Error al sincronizar información del negocio'\n      };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al sincronizar información del negocio'\n    };\n  }\n}","map":{"version":3,"names":["getBusinessInfo","compressImage","checkItemAvailability","DB_NAME","DB_VERSION","SHARED_MENU_STORE","IMAGE_STORE","openDatabase","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","target","errorCode","onsuccess","db","result","version","existingStores","Array","from","objectStoreNames","includes","Error","onupgradeneeded","newVersion","contains","createObjectStore","keyPath","generateMenuId","Math","random","toString","substring","saveMenu","menuItems","menuId","businessInfo","processedItems","all","map","item","processedItem","isSpecial","Boolean","name","image","length","err","warn","menuData","id","items","createdAt","Date","toISOString","jsonSize","JSON","stringify","toFixed","transaction","store","objectStore","put","e","filter","syncBusinessInfoWithBackend","getSharedMenu","isOnline","navigator","onLine","checkRealConnection","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","cache","headers","clearTimeout","ok","menuUtils","cachedMenu","getMenuFromIndexedDB","_fromCache","cacheError","realConnectionPromise","apiService","hasRealConnection","race","default","get","_","success","data","saveMenuToIndexedDB","saveError","serverError","localMenu","localError","localStorage","getItem","parse","businessError","description","contact","address","logo","paymentInfo","qrImage","qrTitle","nequiNumber","nequiImage","bankInfo","otherPaymentMethods","setItem","specialItems","i","regularItems","getMenu","tx","isArray","undefined","normalizedIsSpecial","saveSharedMenu","cleanOldMenus","now","allMenus","getAll","menusToDelete","menu","createdDate","diff","getTime","days","ceil","delete","syncMenuAvailability","sharedMenu","updatedItems","availability","availableQuantity","quantity","updatedMenu","lastSync","Object","keys","message","apiServiceModule","token","setToken","userResponse","user","restaurante_id","restauranteId","restauranteData","nombre","descripcion","direccion","telefono","informacion_pago"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/menuService.js"],"sourcesContent":["import { getBusinessInfo, compressImage, checkItemAvailability } from './storageService';\n\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\nconst SHARED_MENU_STORE = 'sharedMenus';\nconst IMAGE_STORE = 'menuImages';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n        \n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        \n        if (!existingStores.includes(SHARED_MENU_STORE)) {\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\n          return;\n        }\n        \n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n        \n        // Crear almacén para menús compartidos si no existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.log('Creando almacén:', SHARED_MENU_STORE);\n          db.createObjectStore(SHARED_MENU_STORE, { keyPath: 'id' });\n        }\n        \n        // Crear almacén para imágenes si no existe\n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('Creando almacén:', IMAGE_STORE);\n          db.createObjectStore(IMAGE_STORE, { keyPath: 'id' });\n        }\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n/**\n * Genera un ID único para un menú\n * @returns {string} Un ID único\n */\nfunction generateMenuId() {\n  return Math.random().toString(36).substring(2, 10) + \n         Math.random().toString(36).substring(2, 10);\n}\n\n/**\n * Guarda un menú compartido y devuelve su ID\n * @param {Array} menuItems - Elementos del menú a guardar\n * @returns {Promise<String>} - ID del menú compartido\n */\nexport async function saveMenu(menuItems) {\n  try {\n    // Generar un ID único para el menú compartido\n    const menuId = generateMenuId();\n    \n    // Obtener información del negocio para incluirla en el menú compartido\n    const businessInfo = await getBusinessInfo();\n    \n    // Preprocesar los elementos del menú - comprimir imágenes y normalizar isSpecial\n    const processedItems = await Promise.all(menuItems.map(async (item) => {\n      const processedItem = { ...item };\n      processedItem.isSpecial = Boolean(item.isSpecial);\n      console.log(`[saveMenu] Guardando ${item.name} con isSpecial=${processedItem.isSpecial}`);\n      \n      // Comprimir la imagen si existe\n      if (processedItem.image && typeof processedItem.image === 'string' && processedItem.image.length > 0) {\n        try {\n          // Usar una calidad más baja para compartir\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\n        } catch (err) {\n          console.warn('Error al comprimir imagen:', err);\n          processedItem.image = null;\n        }\n      }\n      \n      return processedItem;\n    }));\n    \n    // Crear objeto del menú con información del negocio incluida\n    const menuData = {\n      id: menuId,\n      items: processedItems,\n      businessInfo: businessInfo, // Incluir la información del negocio (con datos de pago)\n      createdAt: new Date().toISOString()\n    };\n    \n    // Verificar tamaño del objeto\n    try {\n      const jsonSize = JSON.stringify(menuData).length / (1024 * 1024); // Tamaño en MB\n      console.log(`Tamaño del menú a guardar: ${jsonSize.toFixed(2)} MB`);\n      \n      if (jsonSize > 50) {\n        throw new Error(`El menú es demasiado grande (${jsonSize.toFixed(2)} MB). Reduce el tamaño de las imágenes.`);\n      }\n    } catch (error) {\n      console.error('Error al verificar tamaño del menú:', error);\n      throw new Error('Error al verificar tamaño del menú');\n    }\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú guardado exitosamente con ID: ${menuId}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Añadir logs de depuración\n    console.log('[saveMenu] Items a guardar:', menuItems.length);\n    console.log('[saveMenu] Items especiales:', menuItems.filter(item => item.isSpecial).length);\n    console.log('[saveMenu] Items regulares:', menuItems.filter(item => !item.isSpecial).length);\n    \n    // Sincronizar información del negocio con el backend\n    await syncBusinessInfoWithBackend();\n    \n    return menuId;\n  } catch (error) {\n    console.error('Error al guardar el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene un menú compartido por su ID\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getSharedMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\n    \n    // Verificar que tenemos un ID válido\n    if (!menuId) {\n      console.error('ID de menú no proporcionado');\n      return null;\n    }\n\n    // Implementación optimizada para priorizar datos en tiempo real con fallback local\n    let menuData = null;\n    let isOnline = navigator.onLine;\n    console.log(`Estado de conexión: ${isOnline ? 'Online' : 'Offline'}`);\n    \n    // Función para verificar conexión real con ping al servidor\n    const checkRealConnection = async () => {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000);\n        const response = await fetch('/api/ping', { \n          signal: controller.signal,\n          cache: 'no-store',\n          headers: { 'Cache-Control': 'no-cache' }\n        });\n        clearTimeout(timeoutId);\n        return response.ok;\n      } catch (e) {\n        console.log('Error al verificar conexión real:', e);\n        return false;\n      }\n    };\n    \n    // Intentaremos primero cargar datos en caché mientras verificamos la conexión real\n    // (Patrón stale-while-revalidate)\n    try {\n      console.log('Intentando cargar menú desde caché mientras verificamos conexión...');\n      const menuUtils = await import('./menuUtils');\n      const cachedMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n      \n      // Si tenemos un menú en caché, lo usamos temporalmente mientras obtenemos datos frescos\n      if (cachedMenu && cachedMenu.items && cachedMenu.items.length > 0) {\n        console.log('Menú en caché encontrado y listo para uso inmediato');\n        menuData = cachedMenu;\n        // Marcamos el menú como potencialmente obsoleto\n        menuData._fromCache = true;\n      }\n    } catch (cacheError) {\n      console.warn('No se pudo obtener menú en caché para uso inmediato:', cacheError);\n    }\n    \n    // Si estamos online, intentamos obtener datos frescos del servidor\n    if (isOnline) {\n      console.log(`Obteniendo menú fresco desde el servidor con ID: ${menuId}`);\n      \n      try {\n        // Comprobación real de conexión en paralelo\n        const realConnectionPromise = checkRealConnection();\n        \n        // Importamos apiService usando import dinámico para evitar problemas de dependencia circular\n        const apiService = await import('./apiService');\n        \n        // Verificamos si realmente tenemos conexión\n        const hasRealConnection = await realConnectionPromise;\n        if (!hasRealConnection) {\n          console.warn('Detectada conexión inestable o sin acceso al servidor');\n          isOnline = false;\n          // Si no tenemos conexión real pero tenemos datos en caché, usamos la caché\n          if (menuData) return menuData;\n          // De lo contrario, continuamos con el proceso de fallback\n          throw new Error('Sin conexión real al servidor');\n        }\n        \n        // Hacemos la petición al servidor para obtener el menú con timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 8000);\n        \n        const response = await Promise.race([\n          apiService.default.get(`/platos/menu/${menuId}`, { signal: controller.signal }),\n          new Promise((_, reject) => \n            setTimeout(() => reject(new Error('Timeout al obtener menú del servidor')), 8000)\n          )\n        ]);\n        \n        clearTimeout(timeoutId);\n        \n        if (response && response.success && response.data) {\n          console.log('Menú recuperado desde el servidor:', response.data);\n          menuData = response.data;\n          menuData._fromCache = false; // Marcamos como datos frescos\n          \n          // Guardar en IndexedDB para tenerlo disponible offline\n          try {\n            const menuUtils = await import('./menuUtils');\n            await menuUtils.saveMenuToIndexedDB(menuId, menuData);\n            console.log('Menú guardado en IndexedDB correctamente');\n          } catch (saveError) {\n            console.warn('No se pudo guardar el menú en IndexedDB:', saveError);\n          }\n        } else {\n          console.warn('La respuesta del servidor no contiene datos válidos:', response);\n          // Si tenemos datos en caché y la respuesta del servidor es inválida, usamos la caché\n          if (menuData && menuData._fromCache) {\n            console.log('Usando datos en caché debido a respuesta inválida del servidor');\n            return menuData;\n          }\n          // Pasamos al fallback si no tenemos caché\n        }\n      } catch (serverError) {\n        console.error('Error al obtener el menú desde el servidor:', serverError);\n        // Si hay error de conexión pero tenemos datos en caché, usamos la caché\n        if (menuData && menuData._fromCache) {\n          console.log('Usando datos en caché debido a error del servidor');\n          return menuData;\n        }\n        // Si no hay caché, pasamos al fallback completo\n        isOnline = false;\n      }\n    }\n    \n    // Si no pudimos obtener datos del servidor o estamos offline,\n    // intentamos recuperar desde IndexedDB como respaldo principal\n    if (!menuData) {\n      try {\n        console.log('Intentando recuperar menú desde IndexedDB...');\n        const menuUtils = await import('./menuUtils');\n        const localMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n        if (localMenu && localMenu.items && localMenu.items.length > 0) {\n          console.log('Menú recuperado desde IndexedDB:', localMenu);\n          menuData = localMenu;\n        } else {\n          console.warn('No se encontró el menú en IndexedDB o no contiene items');\n        }\n      } catch (localError) {\n        console.warn('No se pudo obtener el menú desde IndexedDB:', localError);\n      }\n      \n      // Si tampoco hay datos en IndexedDB, intentamos recuperar de localStorage como último recurso\n      if (!menuData) {\n        try {\n          console.log('Intentando recuperar menú desde localStorage...');\n          const cachedMenu = localStorage.getItem(`menu_${menuId}`);\n          if (cachedMenu) {\n            menuData = JSON.parse(cachedMenu);\n            console.log('Menú recuperado desde localStorage:', menuData);\n          } else {\n            throw new Error('No se encontró el menú en ninguna caché');\n          }\n        } catch (cacheError) {\n          console.error('Error al recuperar menú desde la caché:', cacheError);\n          throw new Error('No se pudo obtener el menú de ninguna fuente');\n        }\n      }\n    }\n    \n    // Si el menú no tiene información de negocio, intentar obtenerla\n    if (menuData && !menuData.businessInfo) {\n      try {\n        const businessInfo = await getBusinessInfo();\n        menuData.businessInfo = businessInfo;\n      } catch (businessError) {\n        console.warn('No se pudo obtener información del negocio:', businessError);\n        // Usar información por defecto si no se puede obtener\n        menuData.businessInfo = {\n          name: 'Restaurante WebSAP',\n          description: 'Deliciosa comida para todos los gustos',\n          contact: 'info@websap.com',\n          address: 'Calle Principal #123',\n          logo: null,\n          paymentInfo: {\n            qrImage: null,\n            qrTitle: 'Escanea para pagar',\n            nequiNumber: null,\n            nequiImage: null,\n            bankInfo: 'Banco XYZ - Cuenta 123456789',\n            otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n          }\n        };\n      }\n    }\n    \n    // Asegurarse de que businessInfo siempre tenga un objeto paymentInfo\n    if (menuData && menuData.businessInfo && !menuData.businessInfo.paymentInfo) {\n      menuData.businessInfo.paymentInfo = {\n        qrImage: null,\n        qrTitle: 'Escanea para pagar',\n        nequiNumber: null,\n        nequiImage: null,\n        bankInfo: 'Banco XYZ - Cuenta 123456789',\n        otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n      };\n    }\n    \n    // Guardar en localStorage para tener un respaldo\n    try {\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify(menuData));\n    } catch (saveError) {\n      console.warn('No se pudo guardar el menú en localStorage:', saveError);\n    }\n    \n    // Añadir logs de depuración con verificaciones de seguridad\n    console.log('[getSharedMenu] Menú recuperado:', menuData);\n    \n    // Usar el operador de encadenamiento opcional para evitar errores\n    const specialItems = menuData?.items?.filter(i => i.isSpecial) || [];\n    const regularItems = menuData?.items?.filter(i => !i.isSpecial) || [];\n    \n    console.log('[getSharedMenu] Items especiales:', specialItems.length);\n    console.log('[getSharedMenu] Items regulares:', regularItems.length);\n    \n    return menuData;\n  } catch (error) {\n    console.error('Error al obtener el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Alias para getSharedMenu para mantener compatibilidad con código existente\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getMenu(menuId) {\n  console.log('Intentando recuperar menú con ID:', menuId);\n  try {\n    const db = await openDatabase();\n    const tx = db.transaction('sharedMenus', 'readonly');\n    const store = tx.objectStore('sharedMenus');\n    \n    // Obtener el menú de la base de datos\n    const request = store.get(menuId);\n    const result = await new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        console.log('Resultado de búsqueda del menú:', request.result);\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al recuperar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Verificar si se encontró el menú\n    if (!result) {\n      console.warn(`No se encontró menú con ID: ${menuId}`);\n      return null;\n    }\n    \n    // Verificar si el menú tiene items y es un array\n    if (result && result.items && Array.isArray(result.items)) {\n      console.log('[menuService] Procesando items en getMenu()');\n      \n      // Procesar cada item para normalizar isSpecial\n      const processedItems = result.items.map(item => {\n        // Si isSpecial no existe, asignar false por defecto\n        if (item.isSpecial === undefined) {\n          console.log(`[menuService] Item ${item.name || 'sin nombre'} sin propiedad isSpecial, asignando false`);\n          return { ...item, isSpecial: false };\n        }\n        \n        // Normalizar isSpecial a un valor booleano\n        const normalizedIsSpecial = \n          item.isSpecial === true || \n          item.isSpecial === 'true' || \n          item.isSpecial === 1 || \n          item.isSpecial === '1';\n        \n        if (typeof item.isSpecial !== 'boolean') {\n          console.log(`[menuService] Normalizando isSpecial para ${item.name}: ${item.isSpecial} (${typeof item.isSpecial}) → ${normalizedIsSpecial}`);\n        }\n        \n        return { ...item, isSpecial: normalizedIsSpecial };\n      });\n      \n      console.log(`[menuService] Procesados ${processedItems.length} items:`, \n        processedItems.map(i => ({ name: i.name, isSpecial: i.isSpecial })));\n      \n      // Devolver el objeto completo con los items procesados\n      return {\n        ...result,\n        items: processedItems\n      }; // Devuelve el objeto completo con los items procesados\n    } else {\n      console.warn('El menú no tiene items o no es un array:', result);\n      \n      // Si no tiene items, devolver el resultado tal cual\n      return result;\n    }\n  } catch (error) {\n    console.error('Error al obtener menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Guarda un menú compartido en IndexedDB\n * @param {Object} menuData - Datos del menú a guardar\n * @returns {Promise<void>}\n */\nexport async function saveSharedMenu(menuData) {\n  try {\n    if (!menuData || !menuData.id) {\n      throw new Error('Datos de menú inválidos');\n    }\n    \n    console.log(`Guardando menú compartido con ID: ${menuData.id}`);\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú compartido guardado exitosamente con ID: ${menuData.id}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú compartido:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    console.log('[saveSharedMenu] Menú guardado en IndexedDB');\n    \n  } catch (error) {\n    console.error('Error al guardar el menú compartido en IndexedDB:', error);\n    throw error;\n  }\n}\n\n/**\n * Limpia menús antiguos que ya no son necesarios\n * @returns {Promise<void>}\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      \n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al obtener menús:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    \n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n    \n    console.log(`Se eliminaron ${menusToDelete.length} menús antiguos`);\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n// Añadir después de getSharedMenu\nexport async function syncMenuAvailability(menuId) {\n  try {\n    const sharedMenu = await getSharedMenu(menuId);\n    if (!sharedMenu || !sharedMenu.items) return null;\n\n    // Actualizar la disponibilidad de cada item\n    const updatedItems = await Promise.all(sharedMenu.items.map(async (item) => {\n      const availability = await checkItemAvailability(item.id);\n      return {\n        ...item,\n        availableQuantity: availability.quantity\n      };\n    }));\n\n    // Actualizar el menú con las nuevas disponibilidades\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n\n    const updatedMenu = {\n      ...sharedMenu,\n      items: updatedItems,\n      lastSync: new Date().toISOString()\n    };\n\n    await store.put(updatedMenu);\n    return updatedMenu;\n  } catch (error) {\n    console.error('Error al sincronizar disponibilidad:', error);\n    return null;\n  }\n}\n\n/**\n * Sincroniza la información del negocio con el backend\n * @param {Object} businessInfo - Información del negocio a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend(businessInfo) {\n  try {\n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n    \n    // Verificar que tenemos información válida\n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.error('No hay información del negocio para sincronizar');\n      return { success: false, message: 'No hay información del negocio para sincronizar' };\n    }\n    \n    // Importar apiService dinámicamente para evitar dependencias circulares\n    const apiServiceModule = await import('./apiService');\n    const apiService = apiServiceModule.default;\n    \n    // Asegurarse de que el token esté configurado\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return { success: false, message: 'No se pudo obtener el restaurante del usuario actual' };\n    }\n    \n    const restauranteId = userResponse.user.restaurante_id;\n    \n    // Asegurarse de que paymentInfo sea un objeto válido\n    const paymentInfo = businessInfo.paymentInfo || {\n      qrImage: null,\n      qrTitle: 'Escanea para pagar',\n      nequiNumber: null,\n      nequiImage: null,\n      bankInfo: 'Banco XYZ - Cuenta 123456789',\n      otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n    };\n    \n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name || '',\n      descripcion: businessInfo.description || '',\n      direccion: businessInfo.address || '',\n      telefono: businessInfo.contact || '',\n      logo: businessInfo.logo || null,\n      informacion_pago: JSON.stringify(paymentInfo)\n    };\n    \n    console.log('Datos a enviar al backend:', restauranteData);\n    \n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    \n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      return { success: true, message: 'Información del negocio sincronizada con éxito' };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return { success: false, message: response.message || 'Error al sincronizar información del negocio' };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return { success: false, message: error.message || 'Error al sincronizar información del negocio' };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}