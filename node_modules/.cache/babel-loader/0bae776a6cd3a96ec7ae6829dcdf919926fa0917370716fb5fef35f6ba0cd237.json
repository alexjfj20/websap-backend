{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport { openDB } from 'idb';\nimport { v4 as uuidv4 } from 'uuid';\nimport apiConfig from '../config/apiConfig';\nconst API_BASE_URL = apiConfig.API_DOMAIN; // URL base para la API\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n\n      // Verificar que los almacenes necesarios existen\n      const storeNames = Array.from(db.objectStoreNames);\n      console.log('Almacenes disponibles:', storeNames);\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id'\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n\n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('entityType', 'entityType', {\n          unique: false\n        });\n        syncQueueStore.createIndex('entityId', 'entityId', {\n          unique: false\n        });\n        syncQueueStore.createIndex('action', 'action', {\n          unique: false\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n\n      // Crear otros almacenes necesarios\n      const requiredStores = ['businessInfo', 'categories', 'soldItems'];\n      requiredStores.forEach(storeName => {\n        if (!db.objectStoreNames.contains(storeName)) {\n          console.log(`Creando almacén ${storeName}...`);\n          db.createObjectStore(storeName, {\n            keyPath: 'id'\n          });\n          console.log(`Almacén ${storeName} creado`);\n        } else {\n          console.log(`El almacén ${storeName} ya existe`);\n        }\n      });\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDatabase = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n\n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        resolve(activePlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n\n    // Verificar si el almacén existe antes de intentar acceder a él\n    if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n      console.warn(`El almacén ${PLATOS_STORE} no existe. Creando la base de datos nuevamente...`);\n      // Cerrar la conexión actual\n      db.close();\n\n      // Incrementar la versión para forzar una actualización\n      const newVersion = DB_VERSION + 1;\n      console.log(`Intentando abrir la base de datos con nueva versión: ${newVersion}`);\n\n      // Crear una nueva promesa para manejar la recreación de la base de datos\n      return new Promise(resolve => {\n        // Devolver un array vacío ya que no hay platos pendientes\n        console.log('Devolviendo array vacío de platos pendientes');\n        resolve([]);\n      });\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readonly');\n        const store = transaction.objectStore(PLATOS_STORE);\n\n        // Verificar si el índice syncStatus existe\n        if (!store.indexNames.contains('syncStatus')) {\n          console.warn('El índice syncStatus no existe en el almacén de platos');\n          resolve([]);\n          return;\n        }\n        const index = store.index('syncStatus');\n        const request = index.getAll('pending');\n        request.onsuccess = event => {\n          const pendingPlatos = event.target.result;\n          console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n          resolve(pendingPlatos);\n        };\n        request.onerror = event => {\n          console.error('Error al obtener platos pendientes:', event);\n          // En caso de error, devolver un array vacío en lugar de rechazar la promesa\n          console.log('Devolviendo array vacío debido a error');\n          resolve([]);\n        };\n      } catch (transactionError) {\n        console.error('Error al crear la transacción:', transactionError);\n        // En caso de error, devolver un array vacío en lugar de rechazar la promesa\n        console.log('Devolviendo array vacío debido a error en la transacción');\n        resolve([]);\n      }\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    // En caso de error, devolver un array vacío en lugar de lanzar una excepción\n    return [];\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n\n  // Convertir booleanos a strings para compatibilidad\n  let validStatus = status;\n  if (typeof status === 'boolean') {\n    validStatus = status === true ? 'synced' : 'pending';\n    console.log(`Convertido estado booleano ${status} a \"${validStatus}\"`);\n  }\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(validStatus)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronización\n          plato.syncStatus = validStatus;\n\n          // Si es pending_deletion, marcar como no disponible también\n          if (validStatus === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${validStatus}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async id => {\n  try {\n    console.log(`Iniciando proceso de eliminación para plato ID: ${id}`);\n\n    // Verificar si estamos en línea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n\n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/api/sync/platos';\n        console.log(`URL completa para sincronización: ${serverUrl}`);\n\n        // Enviar una solicitud POST con operation=delete en lugar de DELETE\n        // Esto es más compatible con algunos servidores y proxies\n        const response = await fetch(serverUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            id: id,\n            operation: 'delete'\n          })\n        });\n\n        // Registrar detalles completos de la respuesta para depuración\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          if (response.ok) {\n            console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n\n            // Si se eliminó correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminación y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminación y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexión a internet, marcando plato ID ${id} para eliminación futura`);\n      // Si estamos offline, marcamos para eliminación y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Función para marcar un plato para eliminación\nconst markPlatoForDeletion = async id => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    return new Promise((resolve, reject) => {\n      request.onerror = event => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n\n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          getRequest.onerror = event => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          getRequest.onsuccess = event => {\n            const plato = event.target.result;\n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminación`);\n              resolve(false);\n              return;\n            }\n\n            // Marcar para eliminación\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n\n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            updateRequest.onerror = event => {\n              console.error(`Error al marcar plato ID ${id} para eliminación:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminación`));\n            };\n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminación`);\n\n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronización)\n              // Esto se hace añadiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              finalUpdateRequest.onerror = event => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacción:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminación:`, error);\n    throw error;\n  }\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  try {\n    // Validación de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    console.log('✅ Validación inicial del plato exitosa');\n\n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n\n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n\n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        request.onsuccess = async event => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n\n          // Crear objeto completo con el ID\n          const createdPlato = {\n            ...platoToCreate\n          };\n\n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n\n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n\n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        request.onerror = event => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        transaction.onerror = event => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n\n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n\n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n\n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = {\n    ...platoData\n  };\n\n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' ? parseFloat(normalizedData.price) || 0 : normalizedData.price || 0;\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n\n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n\n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n\n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && normalizedData.image.length > 200000) {\n    // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n\n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n\n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n\n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n\n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n\n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n\n  // Crear una copia para no modificar el objeto original\n  const syncPlato = {\n    ...plato\n  };\n\n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n\n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n\n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n\n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n\n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n\n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n\n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n\n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n\n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n\n    // Crear objeto mínimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n\n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n\n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificación inmediata para depuración\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = event => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async id => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\nexport { openDatabase, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato, debugIndexedDB, normalizePlatoData, guardarPlato, preparePlatoForSync, compressImageForSync, getPlato };\nexport default {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};","map":{"version":3,"names":["openDB","v4","uuidv4","apiConfig","API_BASE_URL","API_DOMAIN","DB_NAME","DB_VERSION","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","storeNames","Array","from","objectStoreNames","onupgradeneeded","contains","platosStore","createObjectStore","keyPath","createIndex","unique","syncQueueStore","autoIncrement","requiredStores","forEach","storeName","openDatabase","getAllPlatos","transaction","store","objectStore","getAll","allPlatos","length","activePlatos","filter","plato","deleted","getPendingPlatos","warn","close","newVersion","indexNames","index","pendingPlatos","transactionError","updatePlatoSyncStatus","id","status","validStatus","validStatuses","includes","Error","join","getRequest","get","syncStatus","is_available","updateRequest","put","oncomplete","addToSyncQueue","item","add","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","online","navigator","onLine","serverUrl","response","fetch","method","headers","body","JSON","stringify","operation","responseText","text","data","parse","ok","deleteFromIndexedDB","markPlatoForDeletion","parseError","syncError","deleteRequest","updated_at","Date","toISOString","finalUpdateRequest","logDB","name","version","setInterval","verifyPlatoStorage","message","createPlato","trim","platoToCreate","createdAt","updatedAt","localTimestamp","getTime","now","Math","floor","random","createdPlato","type","entityType","entityId","timestamp","platos","found","find","p","listError","setTimeout","verified","verifyError","debugIndexedDB","databases","window","syncQueue","stores","normalizePlatoData","platoData","normalizedData","price","parseFloat","availableQuantity","parseInt","includesDrink","image","image_thumbnail","compressImageForSync","has_local_image","imageDataUrl","startsWith","match","maxLength","actualData","substring","preparePlatoForSync","syncPlato","needsSimplification","_id","imageSize","maxImageSize","imageType","base64Data","reducedData","imageError","image_error","description","Number","Boolean","serializedSize","minimalPlato","oversized","guardarPlato","platoParaGuardar","platoGuardado","savePlato","platoToSave","savedId","savedPlato","verificationResult","getPlato","debugDB"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/indexedDBService.js"],"sourcesContent":["import { openDB } from 'idb';\nimport { v4 as uuidv4 } from 'uuid';\nimport apiConfig from '../config/apiConfig';\n\nconst API_BASE_URL = apiConfig.API_DOMAIN; // URL base para la API\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      \n      // Verificar que los almacenes necesarios existen\n      const storeNames = Array.from(db.objectStoreNames);\n      console.log('Almacenes disponibles:', storeNames);\n      \n      resolve(db);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n      \n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n        platosStore.createIndex('name', 'name', { unique: false });\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n      \n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\n        syncQueueStore.createIndex('entityType', 'entityType', { unique: false });\n        syncQueueStore.createIndex('entityId', 'entityId', { unique: false });\n        syncQueueStore.createIndex('action', 'action', { unique: false });\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n      \n      // Crear otros almacenes necesarios\n      const requiredStores = ['businessInfo', 'categories', 'soldItems'];\n      \n      requiredStores.forEach(storeName => {\n        if (!db.objectStoreNames.contains(storeName)) {\n          console.log(`Creando almacén ${storeName}...`);\n          db.createObjectStore(storeName, { keyPath: 'id' });\n          console.log(`Almacén ${storeName} creado`);\n        } else {\n          console.log(`El almacén ${storeName} ya existe`);\n        }\n      });\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDatabase = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n        \n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        \n        resolve(activePlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    \n    // Verificar si el almacén existe antes de intentar acceder a él\n    if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n      console.warn(`El almacén ${PLATOS_STORE} no existe. Creando la base de datos nuevamente...`);\n      // Cerrar la conexión actual\n      db.close();\n      \n      // Incrementar la versión para forzar una actualización\n      const newVersion = DB_VERSION + 1;\n      console.log(`Intentando abrir la base de datos con nueva versión: ${newVersion}`);\n      \n      // Crear una nueva promesa para manejar la recreación de la base de datos\n      return new Promise((resolve) => {\n        // Devolver un array vacío ya que no hay platos pendientes\n        console.log('Devolviendo array vacío de platos pendientes');\n        resolve([]);\n      });\n    }\n    \n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readonly');\n        const store = transaction.objectStore(PLATOS_STORE);\n        \n        // Verificar si el índice syncStatus existe\n        if (!store.indexNames.contains('syncStatus')) {\n          console.warn('El índice syncStatus no existe en el almacén de platos');\n          resolve([]);\n          return;\n        }\n        \n        const index = store.index('syncStatus');\n        const request = index.getAll('pending');\n        \n        request.onsuccess = (event) => {\n          const pendingPlatos = event.target.result;\n          console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n          resolve(pendingPlatos);\n        };\n        \n        request.onerror = (event) => {\n          console.error('Error al obtener platos pendientes:', event);\n          // En caso de error, devolver un array vacío en lugar de rechazar la promesa\n          console.log('Devolviendo array vacío debido a error');\n          resolve([]);\n        };\n      } catch (transactionError) {\n        console.error('Error al crear la transacción:', transactionError);\n        // En caso de error, devolver un array vacío en lugar de rechazar la promesa\n        console.log('Devolviendo array vacío debido a error en la transacción');\n        resolve([]);\n      }\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    // En caso de error, devolver un array vacío en lugar de lanzar una excepción\n    return [];\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n  \n  // Convertir booleanos a strings para compatibilidad\n  let validStatus = status;\n  if (typeof status === 'boolean') {\n    validStatus = status === true ? 'synced' : 'pending';\n    console.log(`Convertido estado booleano ${status} a \"${validStatus}\"`);\n  }\n  \n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(validStatus)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  \n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        \n        getRequest.onerror = (event) => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        \n        getRequest.onsuccess = (event) => {\n          const plato = event.target.result;\n          \n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n          \n          // Actualizar el estado de sincronización\n          plato.syncStatus = validStatus;\n          \n          // Si es pending_deletion, marcar como no disponible también\n          if (validStatus === 'pending_deletion') {\n            plato.is_available = false;\n          }\n          \n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          \n          updateRequest.onerror = (event) => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          \n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${validStatus}\".`);\n            resolve(true);\n          };\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async (item) => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.add(item);\n      \n      request.onsuccess = (event) => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async (id) => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.delete(id);\n      \n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async (id) => {\n  try {\n    console.log(`Iniciando proceso de eliminación para plato ID: ${id}`);\n    \n    // Verificar si estamos en línea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    \n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n        \n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/api/sync/platos';\n        console.log(`URL completa para sincronización: ${serverUrl}`);\n        \n        // Enviar una solicitud POST con operation=delete en lugar de DELETE\n        // Esto es más compatible con algunos servidores y proxies\n        const response = await fetch(serverUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            id: id,\n            operation: 'delete'\n          })\n        });\n        \n        // Registrar detalles completos de la respuesta para depuración\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          \n          if (response.ok) {\n            console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n            \n            // Si se eliminó correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminación y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminación y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexión a internet, marcando plato ID ${id} para eliminación futura`);\n      // Si estamos offline, marcamos para eliminación y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async (id) => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        const deleteRequest = platosStore.delete(id);\n        \n        deleteRequest.onerror = (event) => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        \n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Función para marcar un plato para eliminación\nconst markPlatoForDeletion = async (id) => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    return new Promise((resolve, reject) => {\n      request.onerror = (event) => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        \n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n          \n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          \n          getRequest.onerror = (event) => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          \n          getRequest.onsuccess = (event) => {\n            const plato = event.target.result;\n            \n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminación`);\n              resolve(false);\n              return;\n            }\n            \n            // Marcar para eliminación\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n            \n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            \n            updateRequest.onerror = (event) => {\n              console.error(`Error al marcar plato ID ${id} para eliminación:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminación`));\n            };\n            \n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminación`);\n              \n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronización)\n              // Esto se hace añadiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              \n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              \n              finalUpdateRequest.onerror = (event) => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          \n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacción:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminación:`, error);\n    throw error;\n  }\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async (id) => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  \n  try {\n    // Validación de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    \n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    console.log('✅ Validación inicial del plato exitosa');\n    \n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    \n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        \n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n        \n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n        \n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        \n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        \n        request.onsuccess = async (event) => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n          \n          // Crear objeto completo con el ID\n          const createdPlato = { ...platoToCreate };\n          \n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n          \n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            \n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n          \n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          \n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        \n        request.onerror = (event) => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        \n        transaction.onerror = (event) => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        \n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  \n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n    \n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n    \n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n    \n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    \n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = { ...platoData };\n  \n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' \n    ? parseFloat(normalizedData.price) || 0 \n    : (normalizedData.price || 0);\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n  \n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n  \n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n  \n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && \n      normalizedData.image.length > 200000) { // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n    \n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n    \n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  \n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n    \n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n    \n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    \n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n    \n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n    \n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  \n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n  \n  // Crear una copia para no modificar el objeto original\n  const syncPlato = { ...plato };\n  \n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n  \n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n    \n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n    \n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      \n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n            \n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            \n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n  \n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  \n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n  \n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n  \n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n  \n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n    \n    // Crear objeto mínimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    \n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  \n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  \n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    \n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n    \n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    \n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async (platoData) => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n      \n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      \n      const db = await openDB();\n      \n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n      \n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      \n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      \n      request.onsuccess = async (event) => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n        \n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = { ...platoToSave, id: savedId };\n        \n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n        \n        // Verificación inmediata para depuración\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        \n        resolve(savedPlato);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n      \n      // Manejar errores de transacción\n      transaction.onerror = (event) => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n      \n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async (id) => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\n\nexport {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  \n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};\n\nexport default {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  \n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}