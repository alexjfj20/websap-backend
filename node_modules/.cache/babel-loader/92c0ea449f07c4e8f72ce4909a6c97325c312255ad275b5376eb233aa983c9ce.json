{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      const userCount = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.length : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.filter(user => user.estado === 'activo').length : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n\n      const inactiveUsers = userCount - activeUsers;\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n          // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n          {\n            tipo: 'user_login',\n            usuario_nombre: 'Admin',\n            accion: 'inició sesión en el sistema',\n            fecha: new Date().toISOString()\n          }, {\n            tipo: 'system',\n            usuario_nombre: 'Sistema',\n            accion: 'realizó una sincronización de datos',\n            fecha: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n          }]\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/dashboard');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n\n    // En caso de error, devolver datos simulados básicos\n    return {\n      success: true,\n      data: {\n        totalUsers: 45,\n        activeUsers: 38,\n        inactiveUsers: 7,\n        activePayments: 28,\n        pendingPayments: 8,\n        overduePayments: 3,\n        totalIncome: 15750000,\n        status: 'Normal',\n        lastBackup: new Date().toISOString(),\n        recentActivity: [{\n          tipo: 'system',\n          usuario_nombre: 'Sistema',\n          accion: 'inició en modo de respaldo',\n          fecha: new Date().toISOString()\n        }]\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems\n      };\n    }\n\n    // En producción, intentar hacer la llamada a la API real\n    try {\n      const response = await apiService.get('/admin/menu-items');\n      return response;\n    } catch (apiError) {\n      // Si hay un error de CORS u otro error de red en producción,\n      // usamos los datos locales como fallback\n      console.warn('Error al conectar con la API remota, utilizando datos locales como fallback:', apiError);\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems,\n        fromLocalStorage: true\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    return {\n      success: false,\n      error: error.message || 'Error al obtener elementos del menú'\n    };\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [{\n          id: 1,\n          name: 'Hamburguesa Clásica',\n          quantity: 45,\n          price: 12000\n        }, {\n          id: 2,\n          name: 'Pizza Margherita',\n          quantity: 38,\n          price: 18000\n        }, {\n          id: 3,\n          name: 'Ensalada César',\n          quantity: 22,\n          price: 9000\n        }, {\n          id: 4,\n          name: 'Pasta Carbonara',\n          quantity: 30,\n          price: 15000\n        }, {\n          id: 5,\n          name: 'Sushi Variado',\n          quantity: 15,\n          price: 25000\n        }]\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/sold-items');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    return {\n      success: false,\n      error: error.message || 'Error al obtener elementos vendidos'\n    };\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // Construir la URL con los parámetros de consulta\n    let url = '/admin/users';\n    const queryParams = [];\n    if (options.searchTerm) {\n      queryParams.push(`search=${encodeURIComponent(options.searchTerm)}`);\n    }\n    if (options.role) {\n      queryParams.push(`role=${encodeURIComponent(options.role)}`);\n    }\n    if (options.status) {\n      queryParams.push(`status=${encodeURIComponent(options.status)}`);\n    }\n    if (queryParams.length > 0) {\n      url += `?${queryParams.join('&')}`;\n    }\n    console.log('Solicitando usuarios a la API:', url);\n\n    // Realizar la petición a la API\n    const response = await apiService.get(url);\n\n    // Verificar si la respuesta es válida\n    if (response && response.success) {\n      console.log(`Recibidos ${response.data.length} usuarios de la API`);\n\n      // Guardar los usuarios en la variable local para uso futuro\n      localUsers = response.data;\n      return {\n        success: true,\n        data: response.data\n      };\n    }\n    throw new Error(response?.message || 'Error al obtener usuarios');\n  } catch (error) {\n    console.error('Error al obtener usuarios:', error);\n\n    // Si hay un error, devolver los usuarios locales si existen\n    if (localUsers.length > 0) {\n      console.log('Usando usuarios en caché:', localUsers.length);\n      return {\n        success: true,\n        data: localUsers\n      };\n    }\n\n    // Si no hay datos en caché, mostrar error pero no usar datos simulados\n    return {\n      success: false,\n      message: `Error al obtener usuarios: ${error.message}`,\n      data: []\n    };\n  }\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // Realizar la petición a la API\n    const response = await apiService.get('/admin/roles');\n    if (response && response.success) {\n      return response;\n    }\n    throw new Error(response?.message || 'Error al obtener roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n\n    // En caso de error, devolver una lista básica de roles para mantener la funcionalidad\n    return {\n      success: false,\n      message: error.message,\n      data: [{\n        id: 1,\n        nombre: 'Superadministrador',\n        descripcion: 'Control total del sistema'\n      }, {\n        id: 2,\n        nombre: 'Administrador',\n        descripcion: 'Gestión de usuarios y configuración'\n      }, {\n        id: 3,\n        nombre: 'Empleado',\n        descripcion: 'Operaciones básicas'\n      }]\n    };\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData - Datos del nuevo usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createUser(userData) {\n  try {\n    // Validar datos mínimos\n    if (!userData.nombre || !userData.email || !userData.password) {\n      return {\n        success: false,\n        message: 'Faltan datos obligatorios'\n      };\n    }\n    console.log('Enviando solicitud para crear usuario:', userData.email);\n\n    // Realizar la petición a la API\n    const response = await apiService.post('/admin/users', userData);\n    if (response && response.success) {\n      console.log('Usuario creado exitosamente:', response.data?.email);\n\n      // Usar los datos devueltos por el backend\n      const newUser = response.data || {\n        id: Date.now(),\n        // ID temporal si no hay uno real\n        nombre: userData.nombre,\n        email: userData.email,\n        telefono: userData.telefono || '',\n        roles: userData.roles,\n        estado: 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n\n      // Actualizar la lista local de usuarios\n      localUsers = [newUser, ...localUsers];\n      return {\n        success: true,\n        message: response.message || 'Usuario creado correctamente',\n        data: newUser\n      };\n    }\n    throw new Error(response?.message || 'Error al crear usuario');\n  } catch (error) {\n    console.error('Error al crear usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear usuario'\n    };\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {number} userId - ID del usuario a actualizar\n * @param {Object} userData - Nuevos datos del usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateUser(userId, userData) {\n  try {\n    console.log(`Actualizando usuario ${userId}:`, userData);\n\n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/users/${userId}`, userData);\n    if (response && response.success) {\n      console.log('Usuario actualizado exitosamente');\n\n      // Actualizar el usuario en la lista local\n      const userIndex = localUsers.findIndex(u => u.id === userId);\n      if (userIndex !== -1) {\n        localUsers[userIndex] = {\n          ...localUsers[userIndex],\n          ...userData,\n          // Mantener el email y el ID original\n          id: userId,\n          email: localUsers[userIndex].email\n        };\n      }\n      return {\n        success: true,\n        message: response.message || 'Usuario actualizado correctamente',\n        data: response.user\n      };\n    }\n    throw new Error(response?.message || 'Error al actualizar usuario');\n  } catch (error) {\n    console.error('Error al actualizar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar usuario'\n    };\n  }\n}\n\n/**\n * Cambia el estado de un usuario (activo/inactivo)\n * @param {number} userId - ID del usuario\n * @param {string} estado - Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(userId, estado) {\n  try {\n    // Validar estado\n    if (estado !== 'activo' && estado !== 'inactivo') {\n      return {\n        success: false,\n        message: 'Estado inválido'\n      };\n    }\n    console.log(`Cambiando estado de usuario ${userId} a ${estado}`);\n\n    // Convertir estado a valor numérico para la API (1 = activo, 0 = inactivo)\n    const activo = estado === 'activo' ? 1 : 0;\n\n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/users/${userId}`, {\n      activo\n    });\n    if (response && response.success) {\n      console.log(`Estado de usuario cambiado exitosamente a ${estado}`);\n\n      // Actualizar el usuario en la lista local\n      const userIndex = localUsers.findIndex(u => u.id === userId);\n      if (userIndex !== -1) {\n        localUsers[userIndex].estado = estado;\n      }\n      return {\n        success: true,\n        message: `Usuario ${estado === 'activo' ? 'activado' : 'desactivado'} correctamente`,\n        data: {\n          id: userId,\n          estado\n        }\n      };\n    }\n    throw new Error(response?.message || `Error al ${estado === 'activo' ? 'activar' : 'desactivar'} usuario`);\n  } catch (error) {\n    console.error(`Error al cambiar estado de usuario a ${estado}:`, error);\n    return {\n      success: false,\n      message: error.message || `Error al ${estado === 'activo' ? 'activar' : 'desactivar'} usuario`\n    };\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {number} userId - ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(userId) {\n  try {\n    console.log(`Eliminando usuario ${userId}`);\n\n    // Realizar la petición a la API\n    const response = await apiService.delete(`/admin/users/${userId}`);\n    if (response && response.success) {\n      console.log('Usuario eliminado exitosamente');\n\n      // Eliminar el usuario de la lista local\n      localUsers = localUsers.filter(u => u.id !== userId);\n      return {\n        success: true,\n        message: response.message || 'Usuario eliminado correctamente'\n      };\n    }\n    throw new Error(response?.message || 'Error al eliminar usuario');\n  } catch (error) {\n    console.error('Error al eliminar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar usuario'\n    };\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [{\n          id: 1,\n          timestamp: new Date().toISOString(),\n          type: 'info',\n          user: 'Admin',\n          message: 'Inicio de sesión exitoso',\n          details: {\n            ip: '192.168.1.1',\n            userAgent: 'Chrome/96.0'\n          }\n        }, {\n          id: 2,\n          timestamp: new Date(Date.now() - 3600000).toISOString(),\n          // 1 hora atrás\n          type: 'warning',\n          user: 'Sistema',\n          message: 'Intento de acceso fallido',\n          details: {\n            ip: '203.0.113.1',\n            userAgent: 'Edge/96.0',\n            attempts: 3\n          }\n        }, {\n          id: 3,\n          timestamp: new Date(Date.now() - 7200000).toISOString(),\n          // 2 horas atrás\n          type: 'error',\n          user: 'Sistema',\n          message: 'Error en la creación de backup',\n          details: {\n            error: 'Espacio insuficiente',\n            code: 'E0023'\n          }\n        }, {\n          id: 4,\n          timestamp: new Date(Date.now() - 86400000).toISOString(),\n          // 1 día atrás\n          type: 'success',\n          user: 'Juan Pérez',\n          message: 'Nuevo usuario creado',\n          details: {\n            newUser: 'carlos@ejemplo.com'\n          }\n        }]\n      });\n    }, 500);\n  });\n}\n\n/**\n * Descarga los registros del sistema en formato CSV\n * @returns {Promise<Object>} Resultado de la operación con datos CSV\n */\nexport async function downloadLogsCSV() {\n  try {\n    // Primero obtenemos los logs\n    const logsResponse = await getLogs();\n    if (!logsResponse.success || !Array.isArray(logsResponse.data)) {\n      throw new Error('No se pudieron obtener los logs para descargar');\n    }\n\n    // Convertir los logs a formato CSV\n    const logs = logsResponse.data;\n\n    // Cabeceras del CSV\n    const headers = ['ID', 'Fecha', 'Tipo', 'Usuario', 'Mensaje', 'Detalles'];\n\n    // Filas de datos\n    const rows = logs.map(log => [log.id || '', log.timestamp || '', log.type || '', log.user || 'Sistema', log.message || '', log.details ? JSON.stringify(log.details) : '']);\n\n    // Combinar cabeceras y filas\n    const csvContent = [headers.join(','), ...rows.map(row => row.map(cell => `\"${String(cell).replace(/\"/g, '\"\"')}\"`).join(','))].join('\\n');\n    return {\n      success: true,\n      data: csvContent,\n      message: 'Logs descargados correctamente'\n    };\n  } catch (error) {\n    console.error('Error al descargar logs en CSV:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al descargar logs'\n    };\n  }\n}\n\n/**\n * Obtiene un elemento del menú por su ID\n * @param {string} itemId - ID del elemento a obtener\n * @returns {Promise<Object>} Elemento del menú\n */\nexport async function getMenuItem(itemId) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      const menuItems = await storageService.getMenuItems();\n      const item = menuItems.find(item => item.id === itemId);\n      if (!item) {\n        return {\n          success: false,\n          message: 'Elemento no encontrado'\n        };\n      }\n      return {\n        success: true,\n        data: item\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get(`/admin/menu-items/${itemId}`);\n    return response;\n  } catch (error) {\n    console.error(`Error al obtener elemento del menú con ID ${itemId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un elemento del inventario\n * @param {string} itemId - ID del elemento a actualizar\n * @param {number} newStock - Nuevo valor de stock\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newStock) {\n  try {\n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/menu-items/${itemId}/stock`, {\n      stock: newStock\n    });\n    if (response && response.success) {\n      return {\n        success: true,\n        message: 'Stock actualizado correctamente',\n        data: response.data\n      };\n    }\n    throw new Error(response?.message || 'Error al actualizar stock');\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar stock'\n    };\n  }\n}\n\n/**\n * Realiza un respaldo del sistema\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createBackup() {\n  try {\n    // En desarrollo, simular respaldo\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      const backupId = Date.now().toString();\n      const backupDate = new Date().toISOString();\n      console.log(`Respaldo creado: ${backupId} (${backupDate})`);\n      return {\n        success: true,\n        message: 'Respaldo creado correctamente',\n        data: {\n          id: backupId,\n          fecha: backupDate,\n          tamaño: '2.3 MB',\n          estado: 'Completado'\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.post('/admin/backups');\n    return response;\n  } catch (error) {\n    console.error('Error al crear respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear respaldo'\n    };\n  }\n}\n\n/**\n * Obtiene la lista de respaldos\n * @returns {Promise<Object>} Lista de respaldos\n */\nexport async function getBackups() {\n  try {\n    // En desarrollo, devolver respaldos simulados\n    if (process.env.NODE_ENV === 'development') {\n      const now = Date.now();\n      return {\n        success: true,\n        data: [{\n          id: '1',\n          fecha: new Date(now - 3600000).toISOString(),\n          // 1 hora atrás\n          tamaño: '2.3 MB',\n          usuario: 'Admin',\n          estado: 'Completado',\n          tipo: 'Manual'\n        }, {\n          id: '2',\n          fecha: new Date(now - 86400000).toISOString(),\n          // 1 día atrás\n          tamaño: '2.1 MB',\n          usuario: 'Sistema',\n          estado: 'Completado',\n          tipo: 'Automático'\n        }, {\n          id: '3',\n          fecha: new Date(now - 172800000).toISOString(),\n          // 2 días atrás\n          tamaño: '2.0 MB',\n          usuario: 'Sistema',\n          estado: 'Completado',\n          tipo: 'Automático'\n        }]\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/backups');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener respaldos:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Restaura el sistema desde un respaldo\n * @param {string} backupId - ID del respaldo a restaurar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function restoreBackup(backupId) {\n  try {\n    // En desarrollo, simular restauración\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      console.log(`Restauración desde respaldo ${backupId} completada`);\n      return {\n        success: true,\n        message: 'Sistema restaurado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.post(`/admin/backups/${backupId}/restore`);\n    return response;\n  } catch (error) {\n    console.error('Error al restaurar desde respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al restaurar desde respaldo'\n    };\n  }\n}\n\n/**\n * Elimina un respaldo\n * @param {string} backupId - ID del respaldo a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteBackup(backupId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Respaldo ${backupId} eliminado`);\n      return {\n        success: true,\n        message: 'Respaldo eliminado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    const response = await apiService.delete(`/admin/backups/${backupId}`);\n    return response;\n  } catch (error) {\n    console.error('Error al eliminar respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar respaldo'\n    };\n  }\n}","map":{"version":3,"names":["storageService","apiService","localUsers","getDashboardStats","process","env","NODE_ENV","usersResponse","getUsers","userCount","success","Array","isArray","data","length","activeUsers","filter","user","estado","Math","floor","inactiveUsers","console","log","totalUsers","activePayments","pendingPayments","overduePayments","totalIncome","status","lastBackup","Date","toISOString","recentActivity","tipo","usuario_nombre","accion","fecha","now","response","get","error","getMenuItems","menuItems","apiError","warn","fromLocalStorage","message","getSoldItems","id","name","quantity","price","options","url","queryParams","searchTerm","push","encodeURIComponent","role","join","Error","getRoles","nombre","descripcion","createUser","userData","email","password","post","newUser","telefono","roles","fecha_creacion","updateUser","userId","put","userIndex","findIndex","u","cambiarEstadoUsuario","activo","deleteUser","delete","getLogs","Promise","resolve","setTimeout","timestamp","type","details","ip","userAgent","attempts","code","downloadLogsCSV","logsResponse","logs","headers","rows","map","JSON","stringify","csvContent","row","cell","String","replace","getMenuItem","itemId","item","find","updateItemStock","newStock","stock","createBackup","backupId","toString","backupDate","tamaño","getBackups","usuario","restoreBackup","deleteBackup"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/adminService.js"],"sourcesContent":["/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      \n      const userCount = (usersResponse && usersResponse.success && Array.isArray(usersResponse.data)) \n        ? usersResponse.data.length \n        : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data)\n        ? usersResponse.data.filter(user => user.estado === 'activo').length\n        : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n        \n      const inactiveUsers = userCount - activeUsers;\n\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n            // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n            {\n              tipo: 'user_login',\n              usuario_nombre: 'Admin',\n              accion: 'inició sesión en el sistema',\n              fecha: new Date().toISOString()\n            },\n            {\n              tipo: 'system',\n              usuario_nombre: 'Sistema',\n              accion: 'realizó una sincronización de datos',\n              fecha: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n            }\n          ]\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/dashboard');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    \n    // En caso de error, devolver datos simulados básicos\n    return {\n      success: true,\n      data: {\n        totalUsers: 45,\n        activeUsers: 38,\n        inactiveUsers: 7,\n        activePayments: 28,\n        pendingPayments: 8,\n        overduePayments: 3,\n        totalIncome: 15750000,\n        status: 'Normal',\n        lastBackup: new Date().toISOString(),\n        recentActivity: [\n          {\n            tipo: 'system',\n            usuario_nombre: 'Sistema',\n            accion: 'inició en modo de respaldo',\n            fecha: new Date().toISOString()\n          }\n        ]\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems,\n      };\n    }\n    \n    // En producción, intentar hacer la llamada a la API real\n    try {\n      const response = await apiService.get('/admin/menu-items');\n      return response;\n    } catch (apiError) {\n      // Si hay un error de CORS u otro error de red en producción,\n      // usamos los datos locales como fallback\n      console.warn('Error al conectar con la API remota, utilizando datos locales como fallback:', apiError);\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems,\n        fromLocalStorage: true\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    return {\n      success: false,\n      error: error.message || 'Error al obtener elementos del menú'\n    };\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [\n          { id: 1, name: 'Hamburguesa Clásica', quantity: 45, price: 12000 },\n          { id: 2, name: 'Pizza Margherita', quantity: 38, price: 18000 },\n          { id: 3, name: 'Ensalada César', quantity: 22, price: 9000 },\n          { id: 4, name: 'Pasta Carbonara', quantity: 30, price: 15000 },\n          { id: 5, name: 'Sushi Variado', quantity: 15, price: 25000 }\n        ]\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/sold-items');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    return {\n      success: false,\n      error: error.message || 'Error al obtener elementos vendidos'\n    };\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // Construir la URL con los parámetros de consulta\n    let url = '/admin/users';\n    const queryParams = [];\n    \n    if (options.searchTerm) {\n      queryParams.push(`search=${encodeURIComponent(options.searchTerm)}`);\n    }\n    \n    if (options.role) {\n      queryParams.push(`role=${encodeURIComponent(options.role)}`);\n    }\n    \n    if (options.status) {\n      queryParams.push(`status=${encodeURIComponent(options.status)}`);\n    }\n    \n    if (queryParams.length > 0) {\n      url += `?${queryParams.join('&')}`;\n    }\n    \n    console.log('Solicitando usuarios a la API:', url);\n    \n    // Realizar la petición a la API\n    const response = await apiService.get(url);\n    \n    // Verificar si la respuesta es válida\n    if (response && response.success) {\n      console.log(`Recibidos ${response.data.length} usuarios de la API`);\n      \n      // Guardar los usuarios en la variable local para uso futuro\n      localUsers = response.data;\n      \n      return {\n        success: true,\n        data: response.data\n      };\n    }\n    \n    throw new Error(response?.message || 'Error al obtener usuarios');\n  } catch (error) {\n    console.error('Error al obtener usuarios:', error);\n    \n    // Si hay un error, devolver los usuarios locales si existen\n    if (localUsers.length > 0) {\n      console.log('Usando usuarios en caché:', localUsers.length);\n      return {\n        success: true,\n        data: localUsers\n      };\n    }\n    \n    // Si no hay datos en caché, mostrar error pero no usar datos simulados\n    return {\n      success: false,\n      message: `Error al obtener usuarios: ${error.message}`,\n      data: []\n    };\n  }\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // Realizar la petición a la API\n    const response = await apiService.get('/admin/roles');\n    \n    if (response && response.success) {\n      return response;\n    }\n    \n    throw new Error(response?.message || 'Error al obtener roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    \n    // En caso de error, devolver una lista básica de roles para mantener la funcionalidad\n    return {\n      success: false,\n      message: error.message,\n      data: [\n        { id: 1, nombre: 'Superadministrador', descripcion: 'Control total del sistema' },\n        { id: 2, nombre: 'Administrador', descripcion: 'Gestión de usuarios y configuración' },\n        { id: 3, nombre: 'Empleado', descripcion: 'Operaciones básicas' }\n      ]\n    };\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData - Datos del nuevo usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createUser(userData) {\n  try {\n    // Validar datos mínimos\n    if (!userData.nombre || !userData.email || !userData.password) {\n      return {\n        success: false,\n        message: 'Faltan datos obligatorios'\n      };\n    }\n    \n    console.log('Enviando solicitud para crear usuario:', userData.email);\n    \n    // Realizar la petición a la API\n    const response = await apiService.post('/admin/users', userData);\n    \n    if (response && response.success) {\n      console.log('Usuario creado exitosamente:', response.data?.email);\n      \n      // Usar los datos devueltos por el backend\n      const newUser = response.data || {\n        id: Date.now(), // ID temporal si no hay uno real\n        nombre: userData.nombre,\n        email: userData.email,\n        telefono: userData.telefono || '',\n        roles: userData.roles,\n        estado: 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n      \n      // Actualizar la lista local de usuarios\n      localUsers = [newUser, ...localUsers];\n      \n      return {\n        success: true,\n        message: response.message || 'Usuario creado correctamente',\n        data: newUser\n      };\n    }\n    \n    throw new Error(response?.message || 'Error al crear usuario');\n  } catch (error) {\n    console.error('Error al crear usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear usuario'\n    };\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {number} userId - ID del usuario a actualizar\n * @param {Object} userData - Nuevos datos del usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateUser(userId, userData) {\n  try {\n    console.log(`Actualizando usuario ${userId}:`, userData);\n    \n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/users/${userId}`, userData);\n    \n    if (response && response.success) {\n      console.log('Usuario actualizado exitosamente');\n      \n      // Actualizar el usuario en la lista local\n      const userIndex = localUsers.findIndex(u => u.id === userId);\n      if (userIndex !== -1) {\n        localUsers[userIndex] = {\n          ...localUsers[userIndex],\n          ...userData,\n          // Mantener el email y el ID original\n          id: userId,\n          email: localUsers[userIndex].email\n        };\n      }\n      \n      return {\n        success: true,\n        message: response.message || 'Usuario actualizado correctamente',\n        data: response.user\n      };\n    }\n    \n    throw new Error(response?.message || 'Error al actualizar usuario');\n  } catch (error) {\n    console.error('Error al actualizar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar usuario'\n    };\n  }\n}\n\n/**\n * Cambia el estado de un usuario (activo/inactivo)\n * @param {number} userId - ID del usuario\n * @param {string} estado - Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(userId, estado) {\n  try {\n    // Validar estado\n    if (estado !== 'activo' && estado !== 'inactivo') {\n      return {\n        success: false,\n        message: 'Estado inválido'\n      };\n    }\n    \n    console.log(`Cambiando estado de usuario ${userId} a ${estado}`);\n    \n    // Convertir estado a valor numérico para la API (1 = activo, 0 = inactivo)\n    const activo = estado === 'activo' ? 1 : 0;\n    \n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/users/${userId}`, { \n      activo \n    });\n    \n    if (response && response.success) {\n      console.log(`Estado de usuario cambiado exitosamente a ${estado}`);\n      \n      // Actualizar el usuario en la lista local\n      const userIndex = localUsers.findIndex(u => u.id === userId);\n      if (userIndex !== -1) {\n        localUsers[userIndex].estado = estado;\n      }\n      \n      return {\n        success: true,\n        message: `Usuario ${estado === 'activo' ? 'activado' : 'desactivado'} correctamente`,\n        data: {\n          id: userId,\n          estado\n        }\n      };\n    }\n    \n    throw new Error(response?.message || `Error al ${estado === 'activo' ? 'activar' : 'desactivar'} usuario`);\n  } catch (error) {\n    console.error(`Error al cambiar estado de usuario a ${estado}:`, error);\n    return {\n      success: false,\n      message: error.message || `Error al ${estado === 'activo' ? 'activar' : 'desactivar'} usuario`\n    };\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {number} userId - ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(userId) {\n  try {\n    console.log(`Eliminando usuario ${userId}`);\n    \n    // Realizar la petición a la API\n    const response = await apiService.delete(`/admin/users/${userId}`);\n    \n    if (response && response.success) {\n      console.log('Usuario eliminado exitosamente');\n      \n      // Eliminar el usuario de la lista local\n      localUsers = localUsers.filter(u => u.id !== userId);\n      \n      return {\n        success: true,\n        message: response.message || 'Usuario eliminado correctamente'\n      };\n    }\n    \n    throw new Error(response?.message || 'Error al eliminar usuario');\n  } catch (error) {\n    console.error('Error al eliminar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar usuario'\n    };\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [\n          {\n            id: 1,\n            timestamp: new Date().toISOString(),\n            type: 'info',\n            user: 'Admin',\n            message: 'Inicio de sesión exitoso',\n            details: { ip: '192.168.1.1', userAgent: 'Chrome/96.0' }\n          },\n          {\n            id: 2,\n            timestamp: new Date(Date.now() - 3600000).toISOString(), // 1 hora atrás\n            type: 'warning',\n            user: 'Sistema',\n            message: 'Intento de acceso fallido',\n            details: { ip: '203.0.113.1', userAgent: 'Edge/96.0', attempts: 3 }\n          },\n          {\n            id: 3,\n            timestamp: new Date(Date.now() - 7200000).toISOString(), // 2 horas atrás\n            type: 'error',\n            user: 'Sistema',\n            message: 'Error en la creación de backup',\n            details: { error: 'Espacio insuficiente', code: 'E0023' }\n          },\n          {\n            id: 4,\n            timestamp: new Date(Date.now() - 86400000).toISOString(), // 1 día atrás\n            type: 'success',\n            user: 'Juan Pérez',\n            message: 'Nuevo usuario creado',\n            details: { newUser: 'carlos@ejemplo.com' }\n          }\n        ]\n      });\n    }, 500);\n  });\n}\n\n/**\n * Descarga los registros del sistema en formato CSV\n * @returns {Promise<Object>} Resultado de la operación con datos CSV\n */\nexport async function downloadLogsCSV() {\n  try {\n    // Primero obtenemos los logs\n    const logsResponse = await getLogs();\n    \n    if (!logsResponse.success || !Array.isArray(logsResponse.data)) {\n      throw new Error('No se pudieron obtener los logs para descargar');\n    }\n    \n    // Convertir los logs a formato CSV\n    const logs = logsResponse.data;\n    \n    // Cabeceras del CSV\n    const headers = ['ID', 'Fecha', 'Tipo', 'Usuario', 'Mensaje', 'Detalles'];\n    \n    // Filas de datos\n    const rows = logs.map(log => [\n      log.id || '',\n      log.timestamp || '',\n      log.type || '',\n      log.user || 'Sistema',\n      log.message || '',\n      log.details ? JSON.stringify(log.details) : ''\n    ]);\n    \n    // Combinar cabeceras y filas\n    const csvContent = [\n      headers.join(','),\n      ...rows.map(row => row.map(cell => `\"${String(cell).replace(/\"/g, '\"\"')}\"`).join(','))\n    ].join('\\n');\n    \n    return {\n      success: true,\n      data: csvContent,\n      message: 'Logs descargados correctamente'\n    };\n  } catch (error) {\n    console.error('Error al descargar logs en CSV:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al descargar logs'\n    };\n  }\n}\n\n/**\n * Obtiene un elemento del menú por su ID\n * @param {string} itemId - ID del elemento a obtener\n * @returns {Promise<Object>} Elemento del menú\n */\nexport async function getMenuItem(itemId) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      const menuItems = await storageService.getMenuItems();\n      const item = menuItems.find(item => item.id === itemId);\n      \n      if (!item) {\n        return {\n          success: false,\n          message: 'Elemento no encontrado'\n        };\n      }\n      \n      return {\n        success: true,\n        data: item\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get(`/admin/menu-items/${itemId}`);\n    return response;\n  } catch (error) {\n    console.error(`Error al obtener elemento del menú con ID ${itemId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un elemento del inventario\n * @param {string} itemId - ID del elemento a actualizar\n * @param {number} newStock - Nuevo valor de stock\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newStock) {\n  try {\n    // Realizar la petición a la API\n    const response = await apiService.put(`/admin/menu-items/${itemId}/stock`, { stock: newStock });\n    \n    if (response && response.success) {\n      return {\n        success: true,\n        message: 'Stock actualizado correctamente',\n        data: response.data\n      };\n    }\n    \n    throw new Error(response?.message || 'Error al actualizar stock');\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar stock'\n    };\n  }\n}\n\n/**\n * Realiza un respaldo del sistema\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createBackup() {\n  try {\n    // En desarrollo, simular respaldo\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      const backupId = Date.now().toString();\n      const backupDate = new Date().toISOString();\n      \n      console.log(`Respaldo creado: ${backupId} (${backupDate})`);\n      \n      return {\n        success: true,\n        message: 'Respaldo creado correctamente',\n        data: {\n          id: backupId,\n          fecha: backupDate,\n          tamaño: '2.3 MB',\n          estado: 'Completado'\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.post('/admin/backups');\n    return response;\n  } catch (error) {\n    console.error('Error al crear respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear respaldo'\n    };\n  }\n}\n\n/**\n * Obtiene la lista de respaldos\n * @returns {Promise<Object>} Lista de respaldos\n */\nexport async function getBackups() {\n  try {\n    // En desarrollo, devolver respaldos simulados\n    if (process.env.NODE_ENV === 'development') {\n      const now = Date.now();\n      \n      return {\n        success: true,\n        data: [\n          {\n            id: '1',\n            fecha: new Date(now - 3600000).toISOString(), // 1 hora atrás\n            tamaño: '2.3 MB',\n            usuario: 'Admin',\n            estado: 'Completado',\n            tipo: 'Manual'\n          },\n          {\n            id: '2',\n            fecha: new Date(now - 86400000).toISOString(), // 1 día atrás\n            tamaño: '2.1 MB',\n            usuario: 'Sistema',\n            estado: 'Completado',\n            tipo: 'Automático'\n          },\n          {\n            id: '3',\n            fecha: new Date(now - 172800000).toISOString(), // 2 días atrás\n            tamaño: '2.0 MB',\n            usuario: 'Sistema',\n            estado: 'Completado',\n            tipo: 'Automático'\n          }\n        ]\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.get('/admin/backups');\n    return response;\n  } catch (error) {\n    console.error('Error al obtener respaldos:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Restaura el sistema desde un respaldo\n * @param {string} backupId - ID del respaldo a restaurar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function restoreBackup(backupId) {\n  try {\n    // En desarrollo, simular restauración\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      console.log(`Restauración desde respaldo ${backupId} completada`);\n      \n      return {\n        success: true,\n        message: 'Sistema restaurado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.post(`/admin/backups/${backupId}/restore`);\n    return response;\n  } catch (error) {\n    console.error('Error al restaurar desde respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al restaurar desde respaldo'\n    };\n  }\n}\n\n/**\n * Elimina un respaldo\n * @param {string} backupId - ID del respaldo a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteBackup(backupId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Respaldo ${backupId} eliminado`);\n      \n      return {\n        success: true,\n        message: 'Respaldo eliminado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    const response = await apiService.delete(`/admin/backups/${backupId}`);\n    return response;\n  } catch (error) {\n    console.error('Error al eliminar respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar respaldo'\n    };\n  }\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA,OAAO,KAAKA,cAAc,MAAM,kBAAkB;AAClD,OAAOC,UAAU,MAAM,cAAc;;AAErC;AACA,IAAIC,UAAU,GAAG,EAAE;;AAEnB;AACA;AACA;AACA;AACA,OAAO,eAAeC,iBAAiBA,CAAA,EAAG;EACxC,IAAI;IACF;IACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C;MACA,MAAMC,aAAa,GAAG,MAAMC,QAAQ,CAAC,CAAC;MAEtC,MAAMC,SAAS,GAAIF,aAAa,IAAIA,aAAa,CAACG,OAAO,IAAIC,KAAK,CAACC,OAAO,CAACL,aAAa,CAACM,IAAI,CAAC,GAC1FN,aAAa,CAACM,IAAI,CAACC,MAAM,GACzB,EAAE,CAAC,CAAC;;MAER;MACA,MAAMC,WAAW,GAAGR,aAAa,IAAIA,aAAa,CAACG,OAAO,IAAIC,KAAK,CAACC,OAAO,CAACL,aAAa,CAACM,IAAI,CAAC,GAC3FN,aAAa,CAACM,IAAI,CAACG,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,MAAM,KAAK,QAAQ,CAAC,CAACJ,MAAM,GAClEK,IAAI,CAACC,KAAK,CAACX,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC;;MAElC,MAAMY,aAAa,GAAGZ,SAAS,GAAGM,WAAW;MAE7CO,OAAO,CAACC,GAAG,CAAC,8BAA8Bd,SAAS,sBAAsBM,WAAW,aAAaM,aAAa,aAAa,CAAC;MAE5H,OAAO;QACLX,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE;UACJW,UAAU,EAAEf,SAAS;UACrBM,WAAW,EAAEA,WAAW;UACxBM,aAAa,EAAEA,aAAa;UAC5BI,cAAc,EAAE,EAAE;UAClBC,eAAe,EAAE,CAAC;UAClBC,eAAe,EAAE,CAAC;UAClBC,WAAW,EAAE,QAAQ;UACrBC,MAAM,EAAE,QAAQ;UAChBC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACpCC,cAAc,EAAE;UACd;UACA;YACEC,IAAI,EAAE,YAAY;YAClBC,cAAc,EAAE,OAAO;YACvBC,MAAM,EAAE,6BAA6B;YACrCC,KAAK,EAAE,IAAIN,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;UAChC,CAAC,EACD;YACEE,IAAI,EAAE,QAAQ;YACdC,cAAc,EAAE,SAAS;YACzBC,MAAM,EAAE,qCAAqC;YAC7CC,KAAK,EAAE,IAAIN,IAAI,CAACA,IAAI,CAACO,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAACN,WAAW,CAAC;UAChE,CAAC;QAEL;MACF,CAAC;IACH;;IAEA;IACA,MAAMO,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,kBAAkB,CAAC;IACzD,OAAOD,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,8CAA8C,EAAEA,KAAK,CAAC;;IAEpE;IACA,OAAO;MACL/B,OAAO,EAAE,IAAI;MACbG,IAAI,EAAE;QACJW,UAAU,EAAE,EAAE;QACdT,WAAW,EAAE,EAAE;QACfM,aAAa,EAAE,CAAC;QAChBI,cAAc,EAAE,EAAE;QAClBC,eAAe,EAAE,CAAC;QAClBC,eAAe,EAAE,CAAC;QAClBC,WAAW,EAAE,QAAQ;QACrBC,MAAM,EAAE,QAAQ;QAChBC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACpCC,cAAc,EAAE,CACd;UACEC,IAAI,EAAE,QAAQ;UACdC,cAAc,EAAE,SAAS;UACzBC,MAAM,EAAE,4BAA4B;UACpCC,KAAK,EAAE,IAAIN,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QAChC,CAAC;MAEL;IACF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeU,YAAYA,CAAA,EAAG;EACnC,IAAI;IACF;IACA,IAAItC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C;MACA,MAAMqC,SAAS,GAAG,MAAM3C,cAAc,CAAC0C,YAAY,CAAC,CAAC;MACrD,OAAO;QACLhC,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE8B;MACR,CAAC;IACH;;IAEA;IACA,IAAI;MACF,MAAMJ,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,mBAAmB,CAAC;MAC1D,OAAOD,QAAQ;IACjB,CAAC,CAAC,OAAOK,QAAQ,EAAE;MACjB;MACA;MACAtB,OAAO,CAACuB,IAAI,CAAC,8EAA8E,EAAED,QAAQ,CAAC;MACtG,MAAMD,SAAS,GAAG,MAAM3C,cAAc,CAAC0C,YAAY,CAAC,CAAC;MACrD,OAAO;QACLhC,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE8B,SAAS;QACfG,gBAAgB,EAAE;MACpB,CAAC;IACH;EACF,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,OAAO;MACL/B,OAAO,EAAE,KAAK;MACd+B,KAAK,EAAEA,KAAK,CAACM,OAAO,IAAI;IAC1B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeC,YAAYA,CAAA,EAAG;EACnC,IAAI;IACF;IACA,IAAI5C,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C,OAAO;QACLI,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE,CACJ;UAAEoC,EAAE,EAAE,CAAC;UAAEC,IAAI,EAAE,qBAAqB;UAAEC,QAAQ,EAAE,EAAE;UAAEC,KAAK,EAAE;QAAM,CAAC,EAClE;UAAEH,EAAE,EAAE,CAAC;UAAEC,IAAI,EAAE,kBAAkB;UAAEC,QAAQ,EAAE,EAAE;UAAEC,KAAK,EAAE;QAAM,CAAC,EAC/D;UAAEH,EAAE,EAAE,CAAC;UAAEC,IAAI,EAAE,gBAAgB;UAAEC,QAAQ,EAAE,EAAE;UAAEC,KAAK,EAAE;QAAK,CAAC,EAC5D;UAAEH,EAAE,EAAE,CAAC;UAAEC,IAAI,EAAE,iBAAiB;UAAEC,QAAQ,EAAE,EAAE;UAAEC,KAAK,EAAE;QAAM,CAAC,EAC9D;UAAEH,EAAE,EAAE,CAAC;UAAEC,IAAI,EAAE,eAAe;UAAEC,QAAQ,EAAE,EAAE;UAAEC,KAAK,EAAE;QAAM,CAAC;MAEhE,CAAC;IACH;;IAEA;IACA,MAAMb,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,mBAAmB,CAAC;IAC1D,OAAOD,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,OAAO;MACL/B,OAAO,EAAE,KAAK;MACd+B,KAAK,EAAEA,KAAK,CAACM,OAAO,IAAI;IAC1B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAevC,QAAQA,CAAC6C,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3C,IAAI;IACF;IACA,IAAIC,GAAG,GAAG,cAAc;IACxB,MAAMC,WAAW,GAAG,EAAE;IAEtB,IAAIF,OAAO,CAACG,UAAU,EAAE;MACtBD,WAAW,CAACE,IAAI,CAAC,UAAUC,kBAAkB,CAACL,OAAO,CAACG,UAAU,CAAC,EAAE,CAAC;IACtE;IAEA,IAAIH,OAAO,CAACM,IAAI,EAAE;MAChBJ,WAAW,CAACE,IAAI,CAAC,QAAQC,kBAAkB,CAACL,OAAO,CAACM,IAAI,CAAC,EAAE,CAAC;IAC9D;IAEA,IAAIN,OAAO,CAACxB,MAAM,EAAE;MAClB0B,WAAW,CAACE,IAAI,CAAC,UAAUC,kBAAkB,CAACL,OAAO,CAACxB,MAAM,CAAC,EAAE,CAAC;IAClE;IAEA,IAAI0B,WAAW,CAACzC,MAAM,GAAG,CAAC,EAAE;MAC1BwC,GAAG,IAAI,IAAIC,WAAW,CAACK,IAAI,CAAC,GAAG,CAAC,EAAE;IACpC;IAEAtC,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAE+B,GAAG,CAAC;;IAElD;IACA,MAAMf,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAACc,GAAG,CAAC;;IAE1C;IACA,IAAIf,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChCY,OAAO,CAACC,GAAG,CAAC,aAAagB,QAAQ,CAAC1B,IAAI,CAACC,MAAM,qBAAqB,CAAC;;MAEnE;MACAZ,UAAU,GAAGqC,QAAQ,CAAC1B,IAAI;MAE1B,OAAO;QACLH,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE0B,QAAQ,CAAC1B;MACjB,CAAC;IACH;IAEA,MAAM,IAAIgD,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,2BAA2B,CAAC;EACnE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;;IAElD;IACA,IAAIvC,UAAU,CAACY,MAAM,GAAG,CAAC,EAAE;MACzBQ,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAErB,UAAU,CAACY,MAAM,CAAC;MAC3D,OAAO;QACLJ,OAAO,EAAE,IAAI;QACbG,IAAI,EAAEX;MACR,CAAC;IACH;;IAEA;IACA,OAAO;MACLQ,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAE,8BAA8BN,KAAK,CAACM,OAAO,EAAE;MACtDlC,IAAI,EAAE;IACR,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeiD,QAAQA,CAAA,EAAG;EAC/B,IAAI;IACF;IACA,MAAMvB,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,cAAc,CAAC;IAErD,IAAID,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChC,OAAO6B,QAAQ;IACjB;IAEA,MAAM,IAAIsB,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,wBAAwB,CAAC;EAChE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;;IAE/C;IACA,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO;MACtBlC,IAAI,EAAE,CACJ;QAAEoC,EAAE,EAAE,CAAC;QAAEc,MAAM,EAAE,oBAAoB;QAAEC,WAAW,EAAE;MAA4B,CAAC,EACjF;QAAEf,EAAE,EAAE,CAAC;QAAEc,MAAM,EAAE,eAAe;QAAEC,WAAW,EAAE;MAAsC,CAAC,EACtF;QAAEf,EAAE,EAAE,CAAC;QAAEc,MAAM,EAAE,UAAU;QAAEC,WAAW,EAAE;MAAsB,CAAC;IAErE,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,UAAUA,CAACC,QAAQ,EAAE;EACzC,IAAI;IACF;IACA,IAAI,CAACA,QAAQ,CAACH,MAAM,IAAI,CAACG,QAAQ,CAACC,KAAK,IAAI,CAACD,QAAQ,CAACE,QAAQ,EAAE;MAC7D,OAAO;QACL1D,OAAO,EAAE,KAAK;QACdqC,OAAO,EAAE;MACX,CAAC;IACH;IAEAzB,OAAO,CAACC,GAAG,CAAC,wCAAwC,EAAE2C,QAAQ,CAACC,KAAK,CAAC;;IAErE;IACA,MAAM5B,QAAQ,GAAG,MAAMtC,UAAU,CAACoE,IAAI,CAAC,cAAc,EAAEH,QAAQ,CAAC;IAEhE,IAAI3B,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChCY,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEgB,QAAQ,CAAC1B,IAAI,EAAEsD,KAAK,CAAC;;MAEjE;MACA,MAAMG,OAAO,GAAG/B,QAAQ,CAAC1B,IAAI,IAAI;QAC/BoC,EAAE,EAAElB,IAAI,CAACO,GAAG,CAAC,CAAC;QAAE;QAChByB,MAAM,EAAEG,QAAQ,CAACH,MAAM;QACvBI,KAAK,EAAED,QAAQ,CAACC,KAAK;QACrBI,QAAQ,EAAEL,QAAQ,CAACK,QAAQ,IAAI,EAAE;QACjCC,KAAK,EAAEN,QAAQ,CAACM,KAAK;QACrBtD,MAAM,EAAE,QAAQ;QAChBuD,cAAc,EAAE,IAAI1C,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACzC,CAAC;;MAED;MACA9B,UAAU,GAAG,CAACoE,OAAO,EAAE,GAAGpE,UAAU,CAAC;MAErC,OAAO;QACLQ,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAER,QAAQ,CAACQ,OAAO,IAAI,8BAA8B;QAC3DlC,IAAI,EAAEyD;MACR,CAAC;IACH;IAEA,MAAM,IAAIT,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,wBAAwB,CAAC;EAChE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe2B,UAAUA,CAACC,MAAM,EAAET,QAAQ,EAAE;EACjD,IAAI;IACF5C,OAAO,CAACC,GAAG,CAAC,wBAAwBoD,MAAM,GAAG,EAAET,QAAQ,CAAC;;IAExD;IACA,MAAM3B,QAAQ,GAAG,MAAMtC,UAAU,CAAC2E,GAAG,CAAC,gBAAgBD,MAAM,EAAE,EAAET,QAAQ,CAAC;IAEzE,IAAI3B,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChCY,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;;MAE/C;MACA,MAAMsD,SAAS,GAAG3E,UAAU,CAAC4E,SAAS,CAACC,CAAC,IAAIA,CAAC,CAAC9B,EAAE,KAAK0B,MAAM,CAAC;MAC5D,IAAIE,SAAS,KAAK,CAAC,CAAC,EAAE;QACpB3E,UAAU,CAAC2E,SAAS,CAAC,GAAG;UACtB,GAAG3E,UAAU,CAAC2E,SAAS,CAAC;UACxB,GAAGX,QAAQ;UACX;UACAjB,EAAE,EAAE0B,MAAM;UACVR,KAAK,EAAEjE,UAAU,CAAC2E,SAAS,CAAC,CAACV;QAC/B,CAAC;MACH;MAEA,OAAO;QACLzD,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAER,QAAQ,CAACQ,OAAO,IAAI,mCAAmC;QAChElC,IAAI,EAAE0B,QAAQ,CAACtB;MACjB,CAAC;IACH;IAEA,MAAM,IAAI4C,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,6BAA6B,CAAC;EACrE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeiC,oBAAoBA,CAACL,MAAM,EAAEzD,MAAM,EAAE;EACzD,IAAI;IACF;IACA,IAAIA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,UAAU,EAAE;MAChD,OAAO;QACLR,OAAO,EAAE,KAAK;QACdqC,OAAO,EAAE;MACX,CAAC;IACH;IAEAzB,OAAO,CAACC,GAAG,CAAC,+BAA+BoD,MAAM,MAAMzD,MAAM,EAAE,CAAC;;IAEhE;IACA,MAAM+D,MAAM,GAAG/D,MAAM,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC;;IAE1C;IACA,MAAMqB,QAAQ,GAAG,MAAMtC,UAAU,CAAC2E,GAAG,CAAC,gBAAgBD,MAAM,EAAE,EAAE;MAC9DM;IACF,CAAC,CAAC;IAEF,IAAI1C,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChCY,OAAO,CAACC,GAAG,CAAC,6CAA6CL,MAAM,EAAE,CAAC;;MAElE;MACA,MAAM2D,SAAS,GAAG3E,UAAU,CAAC4E,SAAS,CAACC,CAAC,IAAIA,CAAC,CAAC9B,EAAE,KAAK0B,MAAM,CAAC;MAC5D,IAAIE,SAAS,KAAK,CAAC,CAAC,EAAE;QACpB3E,UAAU,CAAC2E,SAAS,CAAC,CAAC3D,MAAM,GAAGA,MAAM;MACvC;MAEA,OAAO;QACLR,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAE,WAAW7B,MAAM,KAAK,QAAQ,GAAG,UAAU,GAAG,aAAa,gBAAgB;QACpFL,IAAI,EAAE;UACJoC,EAAE,EAAE0B,MAAM;UACVzD;QACF;MACF,CAAC;IACH;IAEA,MAAM,IAAI2C,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,YAAY7B,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAG,YAAY,UAAU,CAAC;EAC5G,CAAC,CAAC,OAAOuB,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,wCAAwCvB,MAAM,GAAG,EAAEuB,KAAK,CAAC;IACvE,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI,YAAY7B,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAG,YAAY;IACtF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAegE,UAAUA,CAACP,MAAM,EAAE;EACvC,IAAI;IACFrD,OAAO,CAACC,GAAG,CAAC,sBAAsBoD,MAAM,EAAE,CAAC;;IAE3C;IACA,MAAMpC,QAAQ,GAAG,MAAMtC,UAAU,CAACkF,MAAM,CAAC,gBAAgBR,MAAM,EAAE,CAAC;IAElE,IAAIpC,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChCY,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;;MAE7C;MACArB,UAAU,GAAGA,UAAU,CAACc,MAAM,CAAC+D,CAAC,IAAIA,CAAC,CAAC9B,EAAE,KAAK0B,MAAM,CAAC;MAEpD,OAAO;QACLjE,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAER,QAAQ,CAACQ,OAAO,IAAI;MAC/B,CAAC;IACH;IAEA,MAAM,IAAIc,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,2BAA2B,CAAC;EACnE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeqC,OAAOA,CAAA,EAAG;EAC9B,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;IAC9BC,UAAU,CAAC,MAAM;MACfD,OAAO,CAAC;QACN5E,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE,CACJ;UACEoC,EAAE,EAAE,CAAC;UACLuC,SAAS,EAAE,IAAIzD,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCyD,IAAI,EAAE,MAAM;UACZxE,IAAI,EAAE,OAAO;UACb8B,OAAO,EAAE,0BAA0B;UACnC2C,OAAO,EAAE;YAAEC,EAAE,EAAE,aAAa;YAAEC,SAAS,EAAE;UAAc;QACzD,CAAC,EACD;UACE3C,EAAE,EAAE,CAAC;UACLuC,SAAS,EAAE,IAAIzD,IAAI,CAACA,IAAI,CAACO,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UACzDyD,IAAI,EAAE,SAAS;UACfxE,IAAI,EAAE,SAAS;UACf8B,OAAO,EAAE,2BAA2B;UACpC2C,OAAO,EAAE;YAAEC,EAAE,EAAE,aAAa;YAAEC,SAAS,EAAE,WAAW;YAAEC,QAAQ,EAAE;UAAE;QACpE,CAAC,EACD;UACE5C,EAAE,EAAE,CAAC;UACLuC,SAAS,EAAE,IAAIzD,IAAI,CAACA,IAAI,CAACO,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UACzDyD,IAAI,EAAE,OAAO;UACbxE,IAAI,EAAE,SAAS;UACf8B,OAAO,EAAE,gCAAgC;UACzC2C,OAAO,EAAE;YAAEjD,KAAK,EAAE,sBAAsB;YAAEqD,IAAI,EAAE;UAAQ;QAC1D,CAAC,EACD;UACE7C,EAAE,EAAE,CAAC;UACLuC,SAAS,EAAE,IAAIzD,IAAI,CAACA,IAAI,CAACO,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UAC1DyD,IAAI,EAAE,SAAS;UACfxE,IAAI,EAAE,YAAY;UAClB8B,OAAO,EAAE,sBAAsB;UAC/B2C,OAAO,EAAE;YAAEpB,OAAO,EAAE;UAAqB;QAC3C,CAAC;MAEL,CAAC,CAAC;IACJ,CAAC,EAAE,GAAG,CAAC;EACT,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeyB,eAAeA,CAAA,EAAG;EACtC,IAAI;IACF;IACA,MAAMC,YAAY,GAAG,MAAMZ,OAAO,CAAC,CAAC;IAEpC,IAAI,CAACY,YAAY,CAACtF,OAAO,IAAI,CAACC,KAAK,CAACC,OAAO,CAACoF,YAAY,CAACnF,IAAI,CAAC,EAAE;MAC9D,MAAM,IAAIgD,KAAK,CAAC,gDAAgD,CAAC;IACnE;;IAEA;IACA,MAAMoC,IAAI,GAAGD,YAAY,CAACnF,IAAI;;IAE9B;IACA,MAAMqF,OAAO,GAAG,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC;;IAEzE;IACA,MAAMC,IAAI,GAAGF,IAAI,CAACG,GAAG,CAAC7E,GAAG,IAAI,CAC3BA,GAAG,CAAC0B,EAAE,IAAI,EAAE,EACZ1B,GAAG,CAACiE,SAAS,IAAI,EAAE,EACnBjE,GAAG,CAACkE,IAAI,IAAI,EAAE,EACdlE,GAAG,CAACN,IAAI,IAAI,SAAS,EACrBM,GAAG,CAACwB,OAAO,IAAI,EAAE,EACjBxB,GAAG,CAACmE,OAAO,GAAGW,IAAI,CAACC,SAAS,CAAC/E,GAAG,CAACmE,OAAO,CAAC,GAAG,EAAE,CAC/C,CAAC;;IAEF;IACA,MAAMa,UAAU,GAAG,CACjBL,OAAO,CAACtC,IAAI,CAAC,GAAG,CAAC,EACjB,GAAGuC,IAAI,CAACC,GAAG,CAACI,GAAG,IAAIA,GAAG,CAACJ,GAAG,CAACK,IAAI,IAAI,IAAIC,MAAM,CAACD,IAAI,CAAC,CAACE,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC/C,IAAI,CAAC,GAAG,CAAC,CAAC,CACvF,CAACA,IAAI,CAAC,IAAI,CAAC;IAEZ,OAAO;MACLlD,OAAO,EAAE,IAAI;MACbG,IAAI,EAAE0F,UAAU;MAChBxD,OAAO,EAAE;IACX,CAAC;EACH,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe6D,WAAWA,CAACC,MAAM,EAAE;EACxC,IAAI;IACF;IACA,IAAIzG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C,MAAMqC,SAAS,GAAG,MAAM3C,cAAc,CAAC0C,YAAY,CAAC,CAAC;MACrD,MAAMoE,IAAI,GAAGnE,SAAS,CAACoE,IAAI,CAACD,IAAI,IAAIA,IAAI,CAAC7D,EAAE,KAAK4D,MAAM,CAAC;MAEvD,IAAI,CAACC,IAAI,EAAE;QACT,OAAO;UACLpG,OAAO,EAAE,KAAK;UACdqC,OAAO,EAAE;QACX,CAAC;MACH;MAEA,OAAO;QACLrC,OAAO,EAAE,IAAI;QACbG,IAAI,EAAEiG;MACR,CAAC;IACH;;IAEA;IACA,MAAMvE,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,qBAAqBqE,MAAM,EAAE,CAAC;IACpE,OAAOtE,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,6CAA6CoE,MAAM,GAAG,EAAEpE,KAAK,CAAC;IAC5E,MAAMA,KAAK;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeuE,eAAeA,CAACH,MAAM,EAAEI,QAAQ,EAAE;EACtD,IAAI;IACF;IACA,MAAM1E,QAAQ,GAAG,MAAMtC,UAAU,CAAC2E,GAAG,CAAC,qBAAqBiC,MAAM,QAAQ,EAAE;MAAEK,KAAK,EAAED;IAAS,CAAC,CAAC;IAE/F,IAAI1E,QAAQ,IAAIA,QAAQ,CAAC7B,OAAO,EAAE;MAChC,OAAO;QACLA,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAE,iCAAiC;QAC1ClC,IAAI,EAAE0B,QAAQ,CAAC1B;MACjB,CAAC;IACH;IAEA,MAAM,IAAIgD,KAAK,CAACtB,QAAQ,EAAEQ,OAAO,IAAI,2BAA2B,CAAC;EACnE,CAAC,CAAC,OAAON,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeoE,YAAYA,CAAA,EAAG;EACnC,IAAI;IACF;IACA,IAAI/G,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C;MACA,MAAM,IAAI+E,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;MAEvD,MAAM8B,QAAQ,GAAGrF,IAAI,CAACO,GAAG,CAAC,CAAC,CAAC+E,QAAQ,CAAC,CAAC;MACtC,MAAMC,UAAU,GAAG,IAAIvF,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MAE3CV,OAAO,CAACC,GAAG,CAAC,oBAAoB6F,QAAQ,KAAKE,UAAU,GAAG,CAAC;MAE3D,OAAO;QACL5G,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAE,+BAA+B;QACxClC,IAAI,EAAE;UACJoC,EAAE,EAAEmE,QAAQ;UACZ/E,KAAK,EAAEiF,UAAU;UACjBC,MAAM,EAAE,QAAQ;UAChBrG,MAAM,EAAE;QACV;MACF,CAAC;IACH;;IAEA;IACA,MAAMqB,QAAQ,GAAG,MAAMtC,UAAU,CAACoE,IAAI,CAAC,gBAAgB,CAAC;IACxD,OAAO9B,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;IAChD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeyE,UAAUA,CAAA,EAAG;EACjC,IAAI;IACF;IACA,IAAIpH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C,MAAMgC,GAAG,GAAGP,IAAI,CAACO,GAAG,CAAC,CAAC;MAEtB,OAAO;QACL5B,OAAO,EAAE,IAAI;QACbG,IAAI,EAAE,CACJ;UACEoC,EAAE,EAAE,GAAG;UACPZ,KAAK,EAAE,IAAIN,IAAI,CAACO,GAAG,GAAG,OAAO,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UAC9CuF,MAAM,EAAE,QAAQ;UAChBE,OAAO,EAAE,OAAO;UAChBvG,MAAM,EAAE,YAAY;UACpBgB,IAAI,EAAE;QACR,CAAC,EACD;UACEe,EAAE,EAAE,GAAG;UACPZ,KAAK,EAAE,IAAIN,IAAI,CAACO,GAAG,GAAG,QAAQ,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UAC/CuF,MAAM,EAAE,QAAQ;UAChBE,OAAO,EAAE,SAAS;UAClBvG,MAAM,EAAE,YAAY;UACpBgB,IAAI,EAAE;QACR,CAAC,EACD;UACEe,EAAE,EAAE,GAAG;UACPZ,KAAK,EAAE,IAAIN,IAAI,CAACO,GAAG,GAAG,SAAS,CAAC,CAACN,WAAW,CAAC,CAAC;UAAE;UAChDuF,MAAM,EAAE,QAAQ;UAChBE,OAAO,EAAE,SAAS;UAClBvG,MAAM,EAAE,YAAY;UACpBgB,IAAI,EAAE;QACR,CAAC;MAEL,CAAC;IACH;;IAEA;IACA,MAAMK,QAAQ,GAAG,MAAMtC,UAAU,CAACuC,GAAG,CAAC,gBAAgB,CAAC;IACvD,OAAOD,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO;MACtBlC,IAAI,EAAE;IACR,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe6G,aAAaA,CAACN,QAAQ,EAAE;EAC5C,IAAI;IACF;IACA,IAAIhH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1C;MACA,MAAM,IAAI+E,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;MAEvDhE,OAAO,CAACC,GAAG,CAAC,+BAA+B6F,QAAQ,aAAa,CAAC;MAEjE,OAAO;QACL1G,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAE;MACX,CAAC;IACH;;IAEA;IACA,MAAMR,QAAQ,GAAG,MAAMtC,UAAU,CAACoE,IAAI,CAAC,kBAAkB+C,QAAQ,UAAU,CAAC;IAC5E,OAAO7E,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;IAC1D,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe4E,YAAYA,CAACP,QAAQ,EAAE;EAC3C,IAAI;IACF;IACA,IAAIhH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1CgB,OAAO,CAACC,GAAG,CAAC,YAAY6F,QAAQ,YAAY,CAAC;MAE7C,OAAO;QACL1G,OAAO,EAAE,IAAI;QACbqC,OAAO,EAAE;MACX,CAAC;IACH;;IAEA;IACA,MAAMR,QAAQ,GAAG,MAAMtC,UAAU,CAACkF,MAAM,CAAC,kBAAkBiC,QAAQ,EAAE,CAAC;IACtE,OAAO7E,QAAQ;EACjB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdnB,OAAO,CAACmB,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,OAAO;MACL/B,OAAO,EAAE,KAAK;MACdqC,OAAO,EAAEN,KAAK,CAACM,OAAO,IAAI;IAC5B,CAAC;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}