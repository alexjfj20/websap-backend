{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// src/services/syncService.js\n\n// Servicio para gestionar la sincronización y el estado de la conexión\nimport { getPendingPlatos, updatePlatoSyncStatus, getSyncQueue, removeFromSyncQueue, getPlato } from './indexedDBService';\nimport { adaptPlatoData } from '../utils/dataAdapters';\nimport { optimizeImageForSync } from './imageService';\nimport apiConfig from '../config/apiConfig';\nimport { testApiConnection, isOfflineMode } from '../utils/connectionHandler';\n\n// Función para obtener las URLs actualizadas del API\nconst getApiUrls = () => {\n  // Si el API URL fue actualizado por el connectionHandler, actualizar la configuración\n  const storedApiUrl = localStorage.getItem('apiUrl');\n  if (storedApiUrl) {\n    // Construir URLs con el dominio correcto\n    return {\n      API_URL: `${storedApiUrl}/api`,\n      RAW_URL: `${storedApiUrl}/raw`\n    };\n  }\n\n  // Usar configuración por defecto\n  return {\n    API_URL: apiConfig.API_URL,\n    RAW_URL: apiConfig.RAW_URL\n  };\n};\n\n// URLs dinámicas que pueden actualizarse en tiempo de ejecución\nlet {\n  API_URL,\n  RAW_URL\n} = getApiUrls();\n\n// Función para actualizar las URLs de la API en tiempo de ejecución\nconst refreshApiUrls = () => {\n  const urls = getApiUrls();\n  API_URL = urls.API_URL;\n  RAW_URL = urls.RAW_URL;\n  console.log('🔄 URLs de API actualizadas:', {\n    API_URL,\n    RAW_URL\n  });\n};\n\n// Escuchar los cambios de conexión para actualizar las URLs\nwindow.addEventListener('api-connection-change', event => {\n  console.log('🌐 Estado de conexión API cambiado:', event.detail.connected);\n  refreshApiUrls();\n});\n\n// Configuración específica para mejorar la sincronización\nconst SYNC_CONFIG = {\n  skipServerAvailabilityCheck: true,\n  maxPlatoSize: 30000,\n  // 30KB máximo\n  retryIntervals: [5000, 15000, 30000],\n  maxRetries: 2,\n  platoUrl: `${API_URL}/sync/platos`,\n  emergencyPlatoUrl: `${API_URL}/platos/minimal`,\n  useEmergencyEndpoint: true\n};\n\n// Estado de la sincronización\nlet isSyncing = false;\nlet _isOnline = navigator.onLine;\n\n// Alternativa más simple para verificar la conexión\nconst isOnline = async () => {\n  // Primero comprobamos el estado de navigator.onLine\n  if (!navigator.onLine) {\n    return false;\n  }\n\n  // Intentamos hacer un fetch a un recurso pequeño (como un favicon)\n  try {\n    const response = await fetch(`${API_URL}/favicon.ico`, {\n      method: 'HEAD',\n      mode: 'no-cors',\n      cache: 'no-store',\n      credentials: 'omit'\n    });\n    return true; // Si no hay excepción, asumimos que estamos en línea\n  } catch (error) {\n    console.error('Error al verificar estado de conexión:', error);\n    return false;\n  }\n};\n\n// Configurar escuchas para eventos de conexión\nconst setupConnectionListeners = () => {\n  window.addEventListener('online', async () => {\n    console.log('Evento online detectado');\n    _isOnline = await isOnline();\n    if (_isOnline) {\n      console.log('Conexión a Internet restablecida');\n      // Sincronizar cuando se recupera la conexión\n      syncData();\n    }\n  });\n  window.addEventListener('offline', () => {\n    console.log('Evento offline detectado');\n    _isOnline = false;\n    console.log('Conexión a Internet perdida');\n  });\n\n  // Verificar estado inicial\n  isOnline().then(online => {\n    console.log(`Estado inicial de conexión: ${online ? 'En línea' : 'Fuera de línea'}`);\n  });\n};\n\n// Función para probar la conexión con el servidor (modo ultra-ligero)\n// Función para intentar conexión en modo no-cors (evita errores CORS pero con limitaciones)\nconst tryFetchNoCors = async url => {\n  console.log('🔄 Intentando conexión en modo no-cors:', url);\n  return new Promise(resolve => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      console.warn('⏱️ Timeout en la prueba no-cors');\n      controller.abort();\n      resolve(false);\n    }, 5000);\n    fetch(url, {\n      method: 'GET',\n      mode: 'no-cors',\n      // Importante: en este modo no podemos leer la respuesta\n      credentials: 'omit',\n      cache: 'no-store',\n      signal: controller.signal\n    }).then(() => {\n      // En modo no-cors, cualquier respuesta que no sea un error de red\n      // se considera exitosa, aunque no podamos leer su contenido\n      clearTimeout(timeoutId);\n      console.log('✅ Conexión no-cors establecida');\n      resolve(true);\n    }).catch(error => {\n      clearTimeout(timeoutId);\n      console.error('❌ Error en modo no-cors:', error.message);\n      resolve(false);\n    });\n  });\n};\n\n// Función para probar puertos alternativos (3000, 5000, 8000)\nconst checkAlternativePort = async () => {\n  console.log('🔄 Probando puertos alternativos...');\n\n  // Extraer el dominio de la URL actual\n  const apiUrl = getApiUrls().API_URL;\n  const urlObj = new URL(apiUrl);\n  const domain = urlObj.hostname;\n\n  // Lista de puertos comunes para desarrollo\n  const commonPorts = [3000, 5000, 8000];\n  for (const port of commonPorts) {\n    const testUrl = `${urlObj.protocol}//${domain}:${port}/api/test/ping`;\n    console.log(`🔄 Probando puerto alternativo: ${testUrl}`);\n    try {\n      const response = await fetch(testUrl, {\n        method: 'GET',\n        mode: 'no-cors',\n        credentials: 'omit',\n        timeout: 2000 // Tiempo corto para cada puerto\n      });\n      if (response) {\n        console.log(`✅ Puerto alternativo ${port} responde`);\n        // Guardar esta URL como alternativa\n        localStorage.setItem('apiUrl', `${urlObj.protocol}//${domain}:${port}`);\n        return true;\n      }\n    } catch (error) {\n      console.log(`❌ Puerto ${port} no disponible`);\n    }\n  }\n  console.log('❌ No se encontraron puertos alternativos disponibles');\n  return false;\n};\nconst testServerConnection = async () => {\n  console.log('🔄 Probando conexión con el servidor (modo emergencia)...');\n  try {\n    // Usar fetch API que maneja mejor CORS\n    const urls = getApiUrls();\n    const pingURL = `${urls.API_URL}/test/ping`;\n    console.log(`🔄 Probando conexión a: ${pingURL}`);\n    const responsePromise = new Promise(resolve => {\n      // Configurar timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => {\n        console.warn('⏱️ Timeout en la prueba de conexión');\n        controller.abort();\n        resolve(false);\n      }, 8000);\n\n      // Usar fetch con modo no-cors como fallback\n      fetch(pingURL, {\n        method: 'GET',\n        mode: 'cors',\n        credentials: 'omit',\n        // No enviar cookies\n        headers: {\n          'Accept': 'application/json',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        signal: controller.signal\n      }).then(response => {\n        clearTimeout(timeoutId);\n        if (response.ok) {\n          console.log('✅ Conexión básica establecida');\n          resolve(true);\n        } else {\n          console.log(`⚠️ Respuesta no OK: ${response.status}`);\n          // Si es un error CORS, intentar en modo no-cors\n          if (response.status === 0 || response.status === 403) {\n            tryFetchNoCors(pingURL).then(resolve);\n          } else {\n            resolve(false);\n          }\n        }\n      }).catch(error => {\n        clearTimeout(timeoutId);\n        console.error('❌ Error de red en prueba de conexión:', error.message);\n        // Intentar con endpoint de emergencia sin headers\n        checkAlternativePort().then(resolve);\n      });\n    });\n    return await responsePromise;\n  } catch (error) {\n    console.error('❌ Error en prueba de conexión:', error);\n    return false;\n  }\n};\n\n// Comprobar puerto alternativo (implementación secundaria)\nconst checkAlternativePort2 = async () => {\n  console.log('🔄 Probando puertos alternativos (segundo método)...');\n\n  // Lista de puertos comunes para probar\n  const ports = [8080, 3000, 5000, 8000];\n  for (const port of ports) {\n    try {\n      console.log(`Probando en puerto: ${port}`);\n      const response = await fetch(`http://localhost:${port}/raw/ping`, {\n        method: 'GET',\n        mode: 'no-cors',\n        cache: 'no-store',\n        credentials: 'omit'\n      });\n      if (response.ok || response.status === 0) {\n        console.log(`✅ Servidor encontrado en puerto ${port}`);\n        // Actualizar URL global para usar este puerto\n        window.SERVER_PORT = port;\n        return true;\n      }\n    } catch (error) {\n      console.log(`Puerto ${port} no disponible`);\n    }\n  }\n  console.error('❌ No se encontró el servidor en ningún puerto común');\n  return false;\n};\n\n// Función para probar la conexión a MySQL\nconst testMySQLConnection = async () => {\n  console.log('🔄 Probando conexión a MySQL...');\n  try {\n    const response = await fetch(`${API_URL}/test/db`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('✅ Conexión a MySQL establecida:', data);\n\n      // Mostrar información clara sobre la base de datos\n      if (data.data && data.data.database) {\n        console.log(`📊 Base de datos MySQL: ${data.data.database}`);\n        console.log(`📊 Tablas disponibles: ${data.data.tables.join(', ')}`);\n      }\n      return true;\n    } else {\n      console.error('❌ Error al conectar con MySQL:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('❌ Error de red al probar la conexión MySQL:', error);\n    return false;\n  }\n};\n\n// Función para sincronizar datos entre IndexedDB y el servidor\nconst syncData = async () => {\n  if (!(await isOnline())) {\n    console.log('Sin conexión a Internet, la sincronización no es posible');\n    return false;\n  }\n  if (isSyncing) {\n    console.log('Ya hay una sincronización en progreso');\n    return false;\n  }\n  isSyncing = true;\n  console.log('🔄 Iniciando sincronización de datos...');\n  try {\n    // Procesar la cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`📋 Cola de sincronización: ${syncQueue.length} elementos`);\n    for (const item of syncQueue) {\n      if (item.entityType === 'plato') {\n        // Obtener el plato completo de IndexedDB\n        const plato = await getPlato(item.entityId);\n        if (plato) {\n          console.log(`🍽️ Sincronizando plato: ${plato.name} (${plato.id})`);\n          try {\n            // Intentar sincronización minimalista\n            const success = await syncPlato(plato);\n            if (success.success) {\n              console.log(`✅ Plato ${plato.id} sincronizado correctamente`);\n              await removeFromSyncQueue(item.id);\n            } else {\n              console.error(`❌ Error al sincronizar plato ${plato.id}`);\n            }\n          } catch (syncError) {\n            console.error(`❌ Excepción al sincronizar plato ${plato.id}:`, syncError);\n          }\n        } else {\n          console.warn(`⚠️ Plato ${item.entityId} no encontrado en IndexedDB`);\n          await removeFromSyncQueue(item.id);\n        }\n      }\n    }\n\n    // Buscar platos pendientes que no estén en la cola\n    console.log('🔍 Buscando platos pendientes de sincronización...');\n    const pendingPlatos = await getPendingPlatos();\n    console.log(`📋 Platos pendientes: ${pendingPlatos.length}`);\n    for (const plato of pendingPlatos) {\n      try {\n        console.log(`🍽️ Sincronizando plato pendiente: ${plato.name} (${plato.id})`);\n        const success = await syncPlato(plato);\n        if (success.success) {\n          console.log(`✅ Plato pendiente ${plato.id} sincronizado correctamente`);\n        } else {\n          console.error(`❌ Error al sincronizar plato pendiente ${plato.id}: ${success.error}`);\n        }\n      } catch (syncError) {\n        console.error(`❌ Excepción al sincronizar plato pendiente ${plato.id}: ${syncError}`);\n      }\n    }\n    console.log('✅ Sincronización completada');\n    return true;\n  } catch (error) {\n    console.error('❌ Error durante la sincronización:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Método ultra-minimal usando XMLHttpRequest sin headers\nconst tryUltraMinimalSync = async (data, platoId) => {\n  try {\n    console.log('🚨 Intentando sincronización ultra-minimal para plato:', platoId);\n\n    // Crear un objeto XMLHttpRequest directamente\n    const xhr = new XMLHttpRequest();\n\n    // Configurar una promesa para manejar la respuesta\n    const responsePromise = new Promise(resolve => {\n      // Configurar timeout\n      const timeoutId = setTimeout(() => {\n        console.warn('⏱️ Timeout en sincronización ultra-minimal');\n        xhr.abort();\n        resolve(false);\n      }, 15000);\n      xhr.onreadystatechange = async function () {\n        if (xhr.readyState === 4) {\n          clearTimeout(timeoutId);\n          if (xhr.status >= 200 && xhr.status < 300) {\n            console.log('✅ Sincronización ultra-minimal exitosa');\n            try {\n              await updatePlatoSyncStatus(platoId, 'synced');\n            } catch (dbError) {\n              console.error('Error al actualizar estado en BD:', dbError);\n            }\n            resolve(true);\n          } else {\n            console.error(`❌ Error en sincronización ultra-minimal: ${xhr.status}`);\n            resolve(false);\n          }\n        }\n      };\n      xhr.onerror = function () {\n        clearTimeout(timeoutId);\n        console.error('❌ Error de red en sincronización ultra-minimal');\n        resolve(false);\n      };\n    });\n\n    // Usar método POST con datos minimalistas\n    xhr.open('POST', `${API_URL}/platos/emergency-sync`, true);\n\n    // Solo agregar Content-Type, nada más\n    xhr.setRequestHeader('Content-Type', 'application/json');\n\n    // Preparar datos ultra-minimalistas\n    const adaptedData = await adaptPlatoDataWithImageOptimization(data);\n    const minimalData = {\n      id: adaptedData.id,\n      name: (adaptedData.name || \"\").substring(0, 30),\n      price: Number(adaptedData.price) || 0\n    };\n\n    // Enviar los datos\n    xhr.send(JSON.stringify(minimalData));\n    return await responsePromise;\n  } catch (error) {\n    console.error('❌ Error en sincronización ultra-minimal:', error);\n    return false;\n  }\n};\n\n// Procesar la cola de sincronización\nconst processSyncQueue = async () => {\n  if (!(await isOnline()) || isSyncing) {\n    console.log(`No se puede procesar la cola. En línea: ${_isOnline}, Sincronizando: ${isSyncing}`);\n    return false;\n  }\n  isSyncing = true;\n  console.log('Iniciando procesamiento de cola de sincronización...');\n  try {\n    const syncItems = await getSyncQueue();\n    if (syncItems.length === 0) {\n      console.log('No hay elementos en la cola de sincronización');\n      isSyncing = false;\n      return true;\n    }\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronización`);\n\n    // Procesar cada elemento de la cola\n    for (const item of syncItems) {\n      let syncSuccess = false;\n      if (item.type === 'create' && item.entityType === 'plato') {\n        syncSuccess = await syncPlatoToServer(item.data);\n      }\n      // Aquí pueden agregarse más tipos de sincronización según sea necesario\n\n      if (syncSuccess) {\n        // Eliminar de la cola si la sincronización fue exitosa\n        await removeFromSyncQueue(item.id);\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronización`);\n      } else {\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentará más tarde`);\n      }\n    }\n    console.log('Procesamiento de cola de sincronización completado');\n    return true;\n  } catch (error) {\n    console.error('Error al procesar cola de sincronización:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Método de sincronización extremadamente simplificado para problemas persistentes\nexport const syncMinimalDataOnly = async (data, platoId, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n\n  // Usar datos minimalistas pero incluir la imagen optimizada\n  const adaptedData = await adaptPlatoDataWithImageOptimization(data);\n  const minimalData = {\n    id: adaptedData.id,\n    name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n    price: Number(adaptedData.price) || 0,\n    description: adaptedData.description?.substring(0, 100) || '',\n    category: adaptedData.category || 'principal',\n    image: adaptedData.image,\n    // Incluir la imagen optimizada\n    is_available: Boolean(adaptedData.is_available),\n    minimal_sync: true\n  };\n  return new Promise(resolve => {\n    // Establecer timeout para toda la operación\n    const operationTimeoutId = setTimeout(() => {\n      console.warn('⏱️ Timeout global de la operación de sincronización');\n      resolve(false);\n    }, 30000);\n    const xhr = new XMLHttpRequest();\n\n    // Configurar timeouts más estrictos\n    xhr.timeout = 15000;\n    xhr.onreadystatechange = async function () {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          clearTimeout(operationTimeoutId);\n          try {\n            await updatePlatoSyncStatus(platoId, 'synced');\n            console.log(`✅ Sincronización exitosa para plato ${platoId}`);\n          } catch (error) {\n            console.error('Error al actualizar estado:', error);\n          }\n          resolve(true);\n        } else if (xhr.status === 0) {\n          // Conexión abortada o no establecida\n          console.warn('⚠️ Conexión interrumpida');\n          handleRetry();\n        } else if (xhr.status === 431) {\n          console.error(`❌ Error 431 (Headers demasiado grandes) - Intentando método ultraminimal`);\n          tryUltraMinimalSync(adaptedData, platoId).then(success => {\n            clearTimeout(operationTimeoutId);\n            resolve(success);\n          });\n        } else {\n          console.error(`❌ Error HTTP ${xhr.status} en sincronización`);\n          handleRetry();\n        }\n      }\n    };\n    xhr.ontimeout = function () {\n      console.warn('⏱️ Timeout de la petición HTTP');\n      handleRetry();\n    };\n    xhr.onerror = function () {\n      console.error('❌ Error de red en sincronización');\n      handleRetry();\n    };\n\n    // Función para manejar reintentos\n    const handleRetry = () => {\n      if (retryCount < maxRetries) {\n        const delay = SYNC_CONFIG.retryIntervals[retryCount] || 5000;\n        console.log(`🔄 Reintentando en ${delay}ms... (${retryCount + 1}/${maxRetries})`);\n        setTimeout(() => {\n          clearTimeout(operationTimeoutId);\n          syncMinimalDataOnly(data, platoId, retryCount + 1).then(success => resolve(success));\n        }, delay);\n      } else {\n        clearTimeout(operationTimeoutId);\n        console.warn('❌ Agotados todos los reintentos de sincronización');\n        resolve(false);\n      }\n    };\n    try {\n      // Usar método POST con headers mínimos\n      xhr.open('POST', `${API_URL}/platos`, true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n\n      // Enviar los datos minimalistas\n      xhr.send(JSON.stringify(minimalData));\n    } catch (error) {\n      console.error('❌ Error al iniciar la petición:', error);\n      handleRetry();\n    }\n  });\n};\n\n// Sincronizar un plato con el servidor\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n\n  // Si el plato está marcado como problemático, omitirlo\n  if (plato.sync_problematic) {\n    console.warn(`⚠️ Omitiendo plato ${plato.id} marcado como problemático para sincronización`);\n    return false;\n  }\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\n  try {\n    // Omitir verificación si está desactivada\n    if (!SYNC_CONFIG.skipServerAvailabilityCheck) {\n      // Verificar si el servidor está disponible\n      const serverAvailable = await checkServerAvailability();\n      if (!serverAvailable) {\n        console.error('❌ El servidor no está disponible. Posponiendo sincronización.');\n        return false;\n      }\n    }\n\n    // Preparar datos para sincronización incluyendo la imagen\n    let adaptedData = await adaptPlatoDataWithImageOptimization(plato);\n    let syncData = {\n      id: adaptedData.id,\n      name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n      price: Number(adaptedData.price) || 0,\n      description: adaptedData.description?.substring(0, 100) || '',\n      availableQuantity: Number(adaptedData.availableQuantity) || 0,\n      is_available: Boolean(adaptedData.is_available),\n      image: adaptedData.image || null,\n      // Incluir la imagen\n      minimal_sync: true\n    };\n\n    // Usar el método más confiable para sincronización\n    return await syncPlato(adaptedData);\n  } catch (error) {\n    console.error('❌ Error en sincronización:', error);\n    if (retryCount >= maxRetries) {\n      try {\n        await markPlatoAsSyncProblematic(plato.id);\n      } catch (markError) {\n        console.error('Error al marcar plato como problemático:', markError);\n      }\n    }\n    return false;\n  }\n};\n\n// Verificar estado de sincronización con el backend\nconst checkSyncStatus = async () => {\n  try {\n    console.log('🔄 Verificando estado de sincronización...');\n    const response = await fetch(`${API_URL}/sync/status`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      },\n      credentials: 'omit' // Importante: no enviar cookies\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('📊 Estado de sincronización:', data);\n\n      // Si no existe la tabla, intentar crearla\n      if (!data.data.mysql.tablaPlatos) {\n        console.log('⚠️ La tabla platos no existe, intentando configurar...');\n        await setupSync();\n      }\n      return data.data;\n    } else {\n      console.error('❌ Error al verificar estado de sincronización:', await response.text());\n      return null;\n    }\n  } catch (error) {\n    console.error('❌ Error al verificar estado de sincronización:', error);\n    return null;\n  }\n};\n\n// Configurar la sincronización - crear tablas necesarias\nconst setupSync = async () => {\n  try {\n    console.log('🔄 Configurando sincronización...');\n    const response = await fetch(`${API_URL}/sync/setup`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      credentials: 'omit',\n      body: JSON.stringify({\n        force: false\n      })\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('✅ Configuración de sincronización completada:', data);\n      return true;\n    } else {\n      console.error('❌ Error al configurar sincronización:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('❌ Error al configurar sincronización:', error);\n    return false;\n  }\n};\n\n// Inicializar el servicio de sincronización\nconst initSyncService = () => {\n  console.log('🔄 Inicializando servicio de sincronización...');\n\n  // Probar conexiones y configurar sincronización\n  Promise.all([testServerConnection(), checkSyncStatus()]).then(([isApiConnected, syncStatus]) => {\n    console.log(`✅ Estado de conexión directa - API: ${isApiConnected}`);\n    if (isApiConnected) {\n      // Configurar escuchas para eventos de conexión\n      setupConnectionListeners();\n\n      // Si hay estado de sincronización, proceder con la sincronización\n      if (syncStatus && syncStatus.mysql && syncStatus.mysql.connected) {\n        console.log('📊 MySQL conectado, procediendo con sincronización');\n        syncData();\n\n        // Reactivar la sincronización periódica (cada 1 minuto)\n        const syncInterval = setInterval(syncData, 60000);\n      } else {\n        console.log('⚠️ MySQL no está configurado correctamente, intentando configurar...');\n        setupSync().then(success => {\n          if (success) {\n            console.log('✅ Configuración exitosa, iniciando sincronización');\n            syncData();\n\n            // Reactivar la sincronización periódica (cada 1 minuto)\n            const syncInterval = setInterval(syncData, 60000);\n          }\n        });\n      }\n    } else {\n      console.error('❌ No se pudo establecer conexión con el servidor.');\n    }\n  });\n  console.log('⚙️ Servicio de sincronización inicializado');\n};\n\n// Exportar las funciones necesarias\nexport { initSyncService, syncData, isOnline, _isOnline, testServerConnection, testMySQLConnection, checkSyncStatus, setupSync, syncPlato, adaptPlatoDataWithImageOptimization };\n\n// Asegúrate de que la función que maneja la sincronización tenga un mejor manejo de errores\n\n/**\n * Función para sincronizar un plato con el servidor, asegurando que la imagen se incluya\n * @param {Object} plato - El plato a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nconst syncPlato = async plato => {\n  console.log(`🔄 Sincronizando plato: ${plato.name} (ID: ${plato.id})`);\n  try {\n    // Preparar los datos para enviar (incluir la imagen optimizada)\n    const platoToSync = await adaptPlatoDataWithImageOptimization(plato);\n\n    // Omitir la imagen en los logs para evitar mensajes demasiado largos\n    console.log('📤 Datos a enviar:', {\n      ...platoToSync,\n      image: platoToSync.image ? 'Imagen en base64 (omitida en log)' : null\n    });\n\n    // Imprimir la URL exacta para depuración\n    const url = SYNC_CONFIG.platoUrl; // Usar la configuración existente\n    console.log(`🔗 URL de sincronización: ${url}`);\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(platoToSync),\n      // Evitar que se incluyan cookies u otros datos de autenticación si no son necesarios\n      credentials: 'omit'\n    });\n\n    // Verificar si la respuesta es exitosa\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`❌ Error de sincronización (${response.status}): ${errorText}`);\n\n      // Intentar con el método de sincronización minimalista si hay un error\n      if (response.status >= 400) {\n        console.log('⚠️ Intentando sincronización minimalista como fallback...');\n        return await syncMinimalDataOnly(plato);\n      }\n      return {\n        success: false,\n        message: `Error de servidor: ${response.status} ${response.statusText}`,\n        error: errorText\n      };\n    }\n\n    // Procesar la respuesta exitosa\n    const responseData = await response.json();\n    console.log('✅ Sincronización exitosa:', responseData);\n\n    // Actualizar el estado de sincronización en IndexedDB\n    try {\n      await updatePlatoSyncStatus(plato.id, true);\n      console.log(`✅ Estado de sincronización actualizado para plato ID: ${plato.id}`);\n    } catch (syncStatusError) {\n      console.warn(`⚠️ No se pudo actualizar el estado de sincronización: ${syncStatusError.message}`);\n    }\n    return {\n      success: true,\n      message: 'Plato sincronizado correctamente',\n      data: responseData\n    };\n  } catch (error) {\n    console.error('❌ Error en sincronización:', error);\n\n    // Intentar con el método de sincronización minimalista si hay un error\n    console.log('⚠️ Intentando sincronización minimalista como fallback...');\n    return await syncMinimalDataOnly(plato);\n  }\n};\n\n// Función para adaptar los datos del plato antes de sincronizar, con optimización de imágenes\nconst adaptPlatoDataWithImageOptimization = async plato => {\n  // Crear una copia para no modificar el original\n  const adaptedData = {\n    ...plato\n  };\n\n  // Asegurarse de que todos los campos necesarios estén presentes\n  adaptedData.id = plato.id;\n  adaptedData.name = plato.name || 'Plato sin nombre';\n  adaptedData.price = parseFloat(plato.price) || 0;\n  adaptedData.description = plato.description || '';\n  adaptedData.category = plato.category || 'principal';\n\n  // Optimizar la imagen si existe\n  if (plato.image && typeof plato.image === 'string' && plato.image.length > 0) {\n    try {\n      adaptedData.image = await optimizeImageForSync(plato.image);\n      console.log(`Imagen optimizada para ${plato.name}`);\n    } catch (error) {\n      console.warn(`Error al optimizar imagen para ${plato.name}:`, error);\n      adaptedData.image = plato.image; // Usar la original en caso de error\n    }\n  } else {\n    adaptedData.image = plato.image || null;\n  }\n  adaptedData.image_url = plato.image_url || '';\n  adaptedData.is_available = plato.is_available !== false;\n  adaptedData.includesDrink = plato.includesDrink || false;\n  adaptedData.availableQuantity = plato.availableQuantity || 0;\n  return adaptedData;\n};\n\n/**\n * Actualiza el estado de sincronización de un elemento\n * @param {string} id - ID del elemento\n * @param {string|boolean} status - Estado de sincronización ('pending', 'synced', 'pending_deletion' o un booleano)\n * @returns {Promise<boolean>} - true si se actualizó correctamente\n */\nexport async function updateSyncStatus(id, status) {\n  try {\n    // Validar que el status sea uno de los valores permitidos o convertir booleano a string\n    let validStatus = status;\n\n    // Si es booleano, convertirlo al estado correspondiente\n    if (typeof status === 'boolean') {\n      validStatus = status === true ? 'synced' : 'pending';\n    }\n\n    // Ahora validar que sea uno de los estados permitidos\n    if (!['pending', 'synced', 'pending_deletion'].includes(validStatus)) {\n      console.warn(`⚠️ No se pudo actualizar el estado de sincronización: Estado inválido: ${status}. Debe ser uno de: pending, synced, pending_deletion`);\n      return false;\n    }\n\n    // Continuar con la lógica existente para actualizar el estado\n    // ...existing code...\n\n    return true;\n  } catch (error) {\n    console.error('Error al actualizar estado de sincronización:', error);\n    return false;\n  }\n}","map":{"version":3,"names":["getPendingPlatos","updatePlatoSyncStatus","getSyncQueue","removeFromSyncQueue","getPlato","adaptPlatoData","optimizeImageForSync","apiConfig","testApiConnection","isOfflineMode","getApiUrls","storedApiUrl","localStorage","getItem","API_URL","RAW_URL","refreshApiUrls","urls","console","log","window","addEventListener","event","detail","connected","SYNC_CONFIG","skipServerAvailabilityCheck","maxPlatoSize","retryIntervals","maxRetries","platoUrl","emergencyPlatoUrl","useEmergencyEndpoint","isSyncing","_isOnline","navigator","onLine","isOnline","response","fetch","method","mode","cache","credentials","error","setupConnectionListeners","syncData","then","online","tryFetchNoCors","url","Promise","resolve","controller","AbortController","timeoutId","setTimeout","warn","abort","signal","clearTimeout","catch","message","checkAlternativePort","apiUrl","urlObj","URL","domain","hostname","commonPorts","port","testUrl","protocol","timeout","setItem","testServerConnection","pingURL","responsePromise","headers","ok","status","checkAlternativePort2","ports","SERVER_PORT","testMySQLConnection","data","json","database","tables","join","text","syncQueue","length","item","entityType","plato","entityId","name","id","success","syncPlato","syncError","pendingPlatos","tryUltraMinimalSync","platoId","xhr","XMLHttpRequest","onreadystatechange","readyState","dbError","onerror","open","setRequestHeader","adaptedData","adaptPlatoDataWithImageOptimization","minimalData","substring","price","Number","send","JSON","stringify","processSyncQueue","syncItems","syncSuccess","type","syncPlatoToServer","syncMinimalDataOnly","retryCount","description","category","image","is_available","Boolean","minimal_sync","operationTimeoutId","handleRetry","ontimeout","delay","sync_problematic","serverAvailable","checkServerAvailability","availableQuantity","markPlatoAsSyncProblematic","markError","checkSyncStatus","mysql","tablaPlatos","setupSync","body","force","initSyncService","all","isApiConnected","syncStatus","syncInterval","setInterval","platoToSync","errorText","statusText","responseData","syncStatusError","parseFloat","image_url","includesDrink","updateSyncStatus","validStatus","includes"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/syncService.js"],"sourcesContent":["// src/services/syncService.js\n\n// Servicio para gestionar la sincronización y el estado de la conexión\nimport { \n  getPendingPlatos, \n  updatePlatoSyncStatus, \n  getSyncQueue, \n  removeFromSyncQueue,\n  getPlato\n} from './indexedDBService';\nimport { adaptPlatoData } from '../utils/dataAdapters';\nimport { optimizeImageForSync } from './imageService';\nimport apiConfig from '../config/apiConfig';\nimport { testApiConnection, isOfflineMode } from '../utils/connectionHandler';\n\n// Función para obtener las URLs actualizadas del API\nconst getApiUrls = () => {\n  // Si el API URL fue actualizado por el connectionHandler, actualizar la configuración\n  const storedApiUrl = localStorage.getItem('apiUrl');\n  if (storedApiUrl) {\n    // Construir URLs con el dominio correcto\n    return {\n      API_URL: `${storedApiUrl}/api`,\n      RAW_URL: `${storedApiUrl}/raw`\n    };\n  }\n  \n  // Usar configuración por defecto\n  return {\n    API_URL: apiConfig.API_URL,\n    RAW_URL: apiConfig.RAW_URL\n  };\n};\n\n// URLs dinámicas que pueden actualizarse en tiempo de ejecución\nlet { API_URL, RAW_URL } = getApiUrls();\n\n// Función para actualizar las URLs de la API en tiempo de ejecución\nconst refreshApiUrls = () => {\n  const urls = getApiUrls();\n  API_URL = urls.API_URL;\n  RAW_URL = urls.RAW_URL;\n  console.log('🔄 URLs de API actualizadas:', { API_URL, RAW_URL });\n};\n\n// Escuchar los cambios de conexión para actualizar las URLs\nwindow.addEventListener('api-connection-change', (event) => {\n  console.log('🌐 Estado de conexión API cambiado:', event.detail.connected);\n  refreshApiUrls();\n});\n\n// Configuración específica para mejorar la sincronización\nconst SYNC_CONFIG = {\n  skipServerAvailabilityCheck: true,\n  maxPlatoSize: 30000, // 30KB máximo\n  retryIntervals: [5000, 15000, 30000],\n  maxRetries: 2,\n  platoUrl: `${API_URL}/sync/platos`,\n  emergencyPlatoUrl: `${API_URL}/platos/minimal`,\n  useEmergencyEndpoint: true\n};\n\n// Estado de la sincronización\nlet isSyncing = false;\nlet _isOnline = navigator.onLine;\n\n// Alternativa más simple para verificar la conexión\nconst isOnline = async () => {\n  // Primero comprobamos el estado de navigator.onLine\n  if (!navigator.onLine) {\n    return false;\n  }\n  \n  // Intentamos hacer un fetch a un recurso pequeño (como un favicon)\n  try {\n    const response = await fetch(`${API_URL}/favicon.ico`, {\n      method: 'HEAD',\n      mode: 'no-cors',\n      cache: 'no-store',\n      credentials: 'omit'\n    });\n    \n    return true; // Si no hay excepción, asumimos que estamos en línea\n  } catch (error) {\n    console.error('Error al verificar estado de conexión:', error);\n    return false;\n  }\n};\n\n// Configurar escuchas para eventos de conexión\nconst setupConnectionListeners = () => {\n  window.addEventListener('online', async () => {\n    console.log('Evento online detectado');\n    _isOnline = await isOnline();\n    if (_isOnline) {\n      console.log('Conexión a Internet restablecida');\n      // Sincronizar cuando se recupera la conexión\n      syncData();\n    }\n  });\n  \n  window.addEventListener('offline', () => {\n    console.log('Evento offline detectado');\n    _isOnline = false;\n    console.log('Conexión a Internet perdida');\n  });\n  \n  // Verificar estado inicial\n  isOnline().then(online => {\n    console.log(`Estado inicial de conexión: ${online ? 'En línea' : 'Fuera de línea'}`);\n  });\n};\n\n// Función para probar la conexión con el servidor (modo ultra-ligero)\n// Función para intentar conexión en modo no-cors (evita errores CORS pero con limitaciones)\nconst tryFetchNoCors = async (url) => {\n  console.log('🔄 Intentando conexión en modo no-cors:', url);\n  \n  return new Promise((resolve) => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      console.warn('⏱️ Timeout en la prueba no-cors');\n      controller.abort();\n      resolve(false);\n    }, 5000);\n    \n    fetch(url, {\n      method: 'GET',\n      mode: 'no-cors', // Importante: en este modo no podemos leer la respuesta\n      credentials: 'omit',\n      cache: 'no-store',\n      signal: controller.signal\n    })\n    .then(() => {\n      // En modo no-cors, cualquier respuesta que no sea un error de red\n      // se considera exitosa, aunque no podamos leer su contenido\n      clearTimeout(timeoutId);\n      console.log('✅ Conexión no-cors establecida');\n      resolve(true);\n    })\n    .catch(error => {\n      clearTimeout(timeoutId);\n      console.error('❌ Error en modo no-cors:', error.message);\n      resolve(false);\n    });\n  });\n};\n\n// Función para probar puertos alternativos (3000, 5000, 8000)\nconst checkAlternativePort = async () => {\n  console.log('🔄 Probando puertos alternativos...');\n  \n  // Extraer el dominio de la URL actual\n  const apiUrl = getApiUrls().API_URL;\n  const urlObj = new URL(apiUrl);\n  const domain = urlObj.hostname;\n  \n  // Lista de puertos comunes para desarrollo\n  const commonPorts = [3000, 5000, 8000];\n  \n  for (const port of commonPorts) {\n    const testUrl = `${urlObj.protocol}//${domain}:${port}/api/test/ping`;\n    console.log(`🔄 Probando puerto alternativo: ${testUrl}`);\n    \n    try {\n      const response = await fetch(testUrl, {\n        method: 'GET',\n        mode: 'no-cors',\n        credentials: 'omit',\n        timeout: 2000 // Tiempo corto para cada puerto\n      });\n      \n      if (response) {\n        console.log(`✅ Puerto alternativo ${port} responde`);\n        // Guardar esta URL como alternativa\n        localStorage.setItem('apiUrl', `${urlObj.protocol}//${domain}:${port}`);\n        return true;\n      }\n    } catch (error) {\n      console.log(`❌ Puerto ${port} no disponible`);\n    }\n  }\n  \n  console.log('❌ No se encontraron puertos alternativos disponibles');\n  return false;\n};\n\nconst testServerConnection = async () => {\n  console.log('🔄 Probando conexión con el servidor (modo emergencia)...');\n  \n  try {\n    // Usar fetch API que maneja mejor CORS\n    const urls = getApiUrls();\n    const pingURL = `${urls.API_URL}/test/ping`;\n    console.log(`🔄 Probando conexión a: ${pingURL}`);\n    \n    const responsePromise = new Promise((resolve) => {\n      // Configurar timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => {\n        console.warn('⏱️ Timeout en la prueba de conexión');\n        controller.abort();\n        resolve(false);\n      }, 8000);\n      \n      // Usar fetch con modo no-cors como fallback\n      fetch(pingURL, {\n        method: 'GET',\n        mode: 'cors',\n        credentials: 'omit', // No enviar cookies\n        headers: {\n          'Accept': 'application/json',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        signal: controller.signal\n      })\n      .then(response => {\n        clearTimeout(timeoutId);\n        if (response.ok) {\n          console.log('✅ Conexión básica establecida');\n          resolve(true);\n        } else {\n          console.log(`⚠️ Respuesta no OK: ${response.status}`);\n          // Si es un error CORS, intentar en modo no-cors\n          if (response.status === 0 || response.status === 403) {\n            tryFetchNoCors(pingURL).then(resolve);\n          } else {\n            resolve(false);\n          }\n        }\n      })\n      .catch(error => {\n        clearTimeout(timeoutId);\n        console.error('❌ Error de red en prueba de conexión:', error.message);\n        // Intentar con endpoint de emergencia sin headers\n        checkAlternativePort().then(resolve);\n      });\n    });\n    \n    return await responsePromise;\n  } catch (error) {\n    console.error('❌ Error en prueba de conexión:', error);\n    return false;\n  }\n};\n\n// Comprobar puerto alternativo (implementación secundaria)\nconst checkAlternativePort2 = async () => {\n  console.log('🔄 Probando puertos alternativos (segundo método)...');\n  \n  // Lista de puertos comunes para probar\n  const ports = [8080, 3000, 5000, 8000];\n  \n  for (const port of ports) {\n    try {\n      console.log(`Probando en puerto: ${port}`);\n      const response = await fetch(`http://localhost:${port}/raw/ping`, {\n        method: 'GET',\n        mode: 'no-cors',\n        cache: 'no-store',\n        credentials: 'omit'\n      });\n      \n      if (response.ok || response.status === 0) {\n        console.log(`✅ Servidor encontrado en puerto ${port}`);\n        // Actualizar URL global para usar este puerto\n        window.SERVER_PORT = port;\n        return true;\n      }\n    } catch (error) {\n      console.log(`Puerto ${port} no disponible`);\n    }\n  }\n  \n  console.error('❌ No se encontró el servidor en ningún puerto común');\n  return false;\n};\n\n// Función para probar la conexión a MySQL\nconst testMySQLConnection = async () => {\n  console.log('🔄 Probando conexión a MySQL...');\n  \n  try {\n    const response = await fetch(`${API_URL}/test/db`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    \n    if (response.ok) {\n      const data = await response.json();\n      console.log('✅ Conexión a MySQL establecida:', data);\n      \n      // Mostrar información clara sobre la base de datos\n      if (data.data && data.data.database) {\n        console.log(`📊 Base de datos MySQL: ${data.data.database}`);\n        console.log(`📊 Tablas disponibles: ${data.data.tables.join(', ')}`);\n      }\n      \n      return true;\n    } else {\n      console.error('❌ Error al conectar con MySQL:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('❌ Error de red al probar la conexión MySQL:', error);\n    return false;\n  }\n};\n\n// Función para sincronizar datos entre IndexedDB y el servidor\nconst syncData = async () => {\n  if (!await isOnline()) {\n    console.log('Sin conexión a Internet, la sincronización no es posible');\n    return false;\n  }\n  \n  if (isSyncing) {\n    console.log('Ya hay una sincronización en progreso');\n    return false;\n  }\n  \n  isSyncing = true;\n  \n  console.log('🔄 Iniciando sincronización de datos...');\n  \n  try {\n    // Procesar la cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`📋 Cola de sincronización: ${syncQueue.length} elementos`);\n    \n    for (const item of syncQueue) {\n      if (item.entityType === 'plato') {\n        // Obtener el plato completo de IndexedDB\n        const plato = await getPlato(item.entityId);\n        \n        if (plato) {\n          console.log(`🍽️ Sincronizando plato: ${plato.name} (${plato.id})`);\n          \n          try {\n            // Intentar sincronización minimalista\n            const success = await syncPlato(plato);\n            \n            if (success.success) {\n              console.log(`✅ Plato ${plato.id} sincronizado correctamente`);\n              await removeFromSyncQueue(item.id);\n            } else {\n              console.error(`❌ Error al sincronizar plato ${plato.id}`);\n            }\n          } catch (syncError) {\n            console.error(`❌ Excepción al sincronizar plato ${plato.id}:`, syncError);\n          }\n        } else {\n          console.warn(`⚠️ Plato ${item.entityId} no encontrado en IndexedDB`);\n          await removeFromSyncQueue(item.id);\n        }\n      }\n    }\n    \n    // Buscar platos pendientes que no estén en la cola\n    console.log('🔍 Buscando platos pendientes de sincronización...');\n    const pendingPlatos = await getPendingPlatos();\n    console.log(`📋 Platos pendientes: ${pendingPlatos.length}`);\n    \n    for (const plato of pendingPlatos) {\n      try {\n        console.log(`🍽️ Sincronizando plato pendiente: ${plato.name} (${plato.id})`);\n        const success = await syncPlato(plato);\n        \n        if (success.success) {\n          console.log(`✅ Plato pendiente ${plato.id} sincronizado correctamente`);\n        } else {\n          console.error(`❌ Error al sincronizar plato pendiente ${plato.id}: ${success.error}`);\n        }\n      } catch (syncError) {\n        console.error(`❌ Excepción al sincronizar plato pendiente ${plato.id}: ${syncError}`);\n      }\n    }\n    \n    console.log('✅ Sincronización completada');\n    return true;\n  } catch (error) {\n    console.error('❌ Error durante la sincronización:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Método ultra-minimal usando XMLHttpRequest sin headers\nconst tryUltraMinimalSync = async (data, platoId) => {\n  try {\n    console.log('🚨 Intentando sincronización ultra-minimal para plato:', platoId);\n    \n    // Crear un objeto XMLHttpRequest directamente\n    const xhr = new XMLHttpRequest();\n    \n    // Configurar una promesa para manejar la respuesta\n    const responsePromise = new Promise((resolve) => {\n      // Configurar timeout\n      const timeoutId = setTimeout(() => {\n        console.warn('⏱️ Timeout en sincronización ultra-minimal');\n        xhr.abort();\n        resolve(false);\n      }, 15000);\n      \n      xhr.onreadystatechange = async function() {\n        if (xhr.readyState === 4) {\n          clearTimeout(timeoutId);\n          if (xhr.status >= 200 && xhr.status < 300) {\n            console.log('✅ Sincronización ultra-minimal exitosa');\n            try {\n              await updatePlatoSyncStatus(platoId, 'synced');\n            } catch (dbError) {\n              console.error('Error al actualizar estado en BD:', dbError);\n            }\n            resolve(true);\n          } else {\n            console.error(`❌ Error en sincronización ultra-minimal: ${xhr.status}`);\n            resolve(false);\n          }\n        }\n      };\n      \n      xhr.onerror = function() {\n        clearTimeout(timeoutId);\n        console.error('❌ Error de red en sincronización ultra-minimal');\n        resolve(false);\n      };\n    });\n    \n    // Usar método POST con datos minimalistas\n    xhr.open('POST', `${API_URL}/platos/emergency-sync`, true);\n    \n    // Solo agregar Content-Type, nada más\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    \n    // Preparar datos ultra-minimalistas\n    const adaptedData = await adaptPlatoDataWithImageOptimization(data);\n    const minimalData = {\n      id: adaptedData.id,\n      name: (adaptedData.name || \"\").substring(0, 30),\n      price: Number(adaptedData.price) || 0\n    };\n    \n    // Enviar los datos\n    xhr.send(JSON.stringify(minimalData));\n    \n    return await responsePromise;\n  } catch (error) {\n    console.error('❌ Error en sincronización ultra-minimal:', error);\n    return false;\n  }\n};\n\n// Procesar la cola de sincronización\nconst processSyncQueue = async () => {\n  if (!await isOnline() || isSyncing) {\n    console.log(`No se puede procesar la cola. En línea: ${_isOnline}, Sincronizando: ${isSyncing}`);\n    return false;\n  }\n  \n  isSyncing = true;\n  console.log('Iniciando procesamiento de cola de sincronización...');\n  \n  try {\n    const syncItems = await getSyncQueue();\n    \n    if (syncItems.length === 0) {\n      console.log('No hay elementos en la cola de sincronización');\n      isSyncing = false;\n      return true;\n    }\n    \n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronización`);\n    \n    // Procesar cada elemento de la cola\n    for (const item of syncItems) {\n      let syncSuccess = false;\n      \n      if (item.type === 'create' && item.entityType === 'plato') {\n        syncSuccess = await syncPlatoToServer(item.data);\n      }\n      // Aquí pueden agregarse más tipos de sincronización según sea necesario\n      \n      if (syncSuccess) {\n        // Eliminar de la cola si la sincronización fue exitosa\n        await removeFromSyncQueue(item.id);\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronización`);\n      } else {\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentará más tarde`);\n      }\n    }\n    \n    console.log('Procesamiento de cola de sincronización completado');\n    return true;\n  } catch (error) {\n    console.error('Error al procesar cola de sincronización:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Método de sincronización extremadamente simplificado para problemas persistentes\nexport const syncMinimalDataOnly = async (data, platoId, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n  \n  // Usar datos minimalistas pero incluir la imagen optimizada\n  const adaptedData = await adaptPlatoDataWithImageOptimization(data);\n  const minimalData = {\n    id: adaptedData.id,\n    name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n    price: Number(adaptedData.price) || 0,\n    description: adaptedData.description?.substring(0, 100) || '',\n    category: adaptedData.category || 'principal',\n    image: adaptedData.image, // Incluir la imagen optimizada\n    is_available: Boolean(adaptedData.is_available),\n    minimal_sync: true\n  };\n  \n  return new Promise((resolve) => {\n    // Establecer timeout para toda la operación\n    const operationTimeoutId = setTimeout(() => {\n      console.warn('⏱️ Timeout global de la operación de sincronización');\n      resolve(false);\n    }, 30000);\n    \n    const xhr = new XMLHttpRequest();\n    \n    // Configurar timeouts más estrictos\n    xhr.timeout = 15000;\n    \n    xhr.onreadystatechange = async function() {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          clearTimeout(operationTimeoutId);\n          try {\n            await updatePlatoSyncStatus(platoId, 'synced');\n            console.log(`✅ Sincronización exitosa para plato ${platoId}`);\n          } catch (error) {\n            console.error('Error al actualizar estado:', error);\n          }\n          resolve(true);\n        } else if (xhr.status === 0) {\n          // Conexión abortada o no establecida\n          console.warn('⚠️ Conexión interrumpida');\n          handleRetry();\n        } else if (xhr.status === 431) {\n          console.error(`❌ Error 431 (Headers demasiado grandes) - Intentando método ultraminimal`);\n          tryUltraMinimalSync(adaptedData, platoId).then(success => {\n            clearTimeout(operationTimeoutId);\n            resolve(success);\n          });\n        } else {\n          console.error(`❌ Error HTTP ${xhr.status} en sincronización`);\n          handleRetry();\n        }\n      }\n    };\n    \n    xhr.ontimeout = function() {\n      console.warn('⏱️ Timeout de la petición HTTP');\n      handleRetry();\n    };\n    \n    xhr.onerror = function() {\n      console.error('❌ Error de red en sincronización');\n      handleRetry();\n    };\n    \n    // Función para manejar reintentos\n    const handleRetry = () => {\n      if (retryCount < maxRetries) {\n        const delay = SYNC_CONFIG.retryIntervals[retryCount] || 5000;\n        console.log(`🔄 Reintentando en ${delay}ms... (${retryCount + 1}/${maxRetries})`);\n        \n        setTimeout(() => {\n          clearTimeout(operationTimeoutId);\n          syncMinimalDataOnly(data, platoId, retryCount + 1)\n            .then(success => resolve(success));\n        }, delay);\n      } else {\n        clearTimeout(operationTimeoutId);\n        console.warn('❌ Agotados todos los reintentos de sincronización');\n        resolve(false);\n      }\n    };\n    \n    try {\n      // Usar método POST con headers mínimos\n      xhr.open('POST', `${API_URL}/platos`, true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      \n      // Enviar los datos minimalistas\n      xhr.send(JSON.stringify(minimalData));\n    } catch (error) {\n      console.error('❌ Error al iniciar la petición:', error);\n      handleRetry();\n    }\n  });\n};\n\n// Sincronizar un plato con el servidor\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n  \n  // Si el plato está marcado como problemático, omitirlo\n  if (plato.sync_problematic) {\n    console.warn(`⚠️ Omitiendo plato ${plato.id} marcado como problemático para sincronización`);\n    return false;\n  }\n  \n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\n  \n  try {\n    // Omitir verificación si está desactivada\n    if (!SYNC_CONFIG.skipServerAvailabilityCheck) {\n      // Verificar si el servidor está disponible\n      const serverAvailable = await checkServerAvailability();\n      if (!serverAvailable) {\n        console.error('❌ El servidor no está disponible. Posponiendo sincronización.');\n        return false;\n      }\n    }\n    \n    // Preparar datos para sincronización incluyendo la imagen\n    let adaptedData = await adaptPlatoDataWithImageOptimization(plato);\n    let syncData = {\n      id: adaptedData.id,\n      name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n      price: Number(adaptedData.price) || 0,\n      description: adaptedData.description?.substring(0, 100) || '',\n      availableQuantity: Number(adaptedData.availableQuantity) || 0,\n      is_available: Boolean(adaptedData.is_available),\n      image: adaptedData.image || null, // Incluir la imagen\n      minimal_sync: true\n    };\n    \n    // Usar el método más confiable para sincronización\n    return await syncPlato(adaptedData);\n  } catch (error) {\n    console.error('❌ Error en sincronización:', error);\n    \n    if (retryCount >= maxRetries) {\n      try {\n        await markPlatoAsSyncProblematic(plato.id);\n      } catch (markError) {\n        console.error('Error al marcar plato como problemático:', markError);\n      }\n    }\n    \n    return false;\n  }\n};\n\n// Verificar estado de sincronización con el backend\nconst checkSyncStatus = async () => {\n  try {\n    console.log('🔄 Verificando estado de sincronización...');\n    \n    const response = await fetch(`${API_URL}/sync/status`, {\n      method: 'GET',\n      headers: { 'Accept': 'application/json' },\n      credentials: 'omit' // Importante: no enviar cookies\n    });\n    \n    if (response.ok) {\n      const data = await response.json();\n      console.log('📊 Estado de sincronización:', data);\n      \n      // Si no existe la tabla, intentar crearla\n      if (!data.data.mysql.tablaPlatos) {\n        console.log('⚠️ La tabla platos no existe, intentando configurar...');\n        await setupSync();\n      }\n      \n      return data.data;\n    } else {\n      console.error('❌ Error al verificar estado de sincronización:', await response.text());\n      return null;\n    }\n  } catch (error) {\n    console.error('❌ Error al verificar estado de sincronización:', error);\n    return null;\n  }\n};\n\n// Configurar la sincronización - crear tablas necesarias\nconst setupSync = async () => {\n  try {\n    console.log('🔄 Configurando sincronización...');\n    \n    const response = await fetch(`${API_URL}/sync/setup`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      credentials: 'omit',\n      body: JSON.stringify({ force: false })\n    });\n    \n    if (response.ok) {\n      const data = await response.json();\n      console.log('✅ Configuración de sincronización completada:', data);\n      return true;\n    } else {\n      console.error('❌ Error al configurar sincronización:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('❌ Error al configurar sincronización:', error);\n    return false;\n  }\n};\n\n// Inicializar el servicio de sincronización\nconst initSyncService = () => {\n  console.log('🔄 Inicializando servicio de sincronización...');\n  \n  // Probar conexiones y configurar sincronización\n  Promise.all([\n    testServerConnection(),\n    checkSyncStatus()\n  ]).then(([isApiConnected, syncStatus]) => {\n    console.log(`✅ Estado de conexión directa - API: ${isApiConnected}`);\n    \n    if (isApiConnected) {\n      // Configurar escuchas para eventos de conexión\n      setupConnectionListeners();\n      \n      // Si hay estado de sincronización, proceder con la sincronización\n      if (syncStatus && syncStatus.mysql && syncStatus.mysql.connected) {\n        console.log('📊 MySQL conectado, procediendo con sincronización');\n        syncData();\n        \n        // Reactivar la sincronización periódica (cada 1 minuto)\n        const syncInterval = setInterval(syncData, 60000);\n      } else {\n        console.log('⚠️ MySQL no está configurado correctamente, intentando configurar...');\n        setupSync().then(success => {\n          if (success) {\n            console.log('✅ Configuración exitosa, iniciando sincronización');\n            syncData();\n            \n            // Reactivar la sincronización periódica (cada 1 minuto)\n            const syncInterval = setInterval(syncData, 60000);\n          }\n        });\n      }\n    } else {\n      console.error('❌ No se pudo establecer conexión con el servidor.');\n    }\n  });\n  \n  console.log('⚙️ Servicio de sincronización inicializado');\n};\n\n// Exportar las funciones necesarias\nexport {\n  initSyncService,\n  syncData,\n  isOnline,\n  _isOnline,\n  testServerConnection,\n  testMySQLConnection,\n  checkSyncStatus,\n  setupSync,\n  syncPlato,\n  adaptPlatoDataWithImageOptimization\n};\n\n// Asegúrate de que la función que maneja la sincronización tenga un mejor manejo de errores\n\n/**\n * Función para sincronizar un plato con el servidor, asegurando que la imagen se incluya\n * @param {Object} plato - El plato a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nconst syncPlato = async (plato) => {\n  console.log(`🔄 Sincronizando plato: ${plato.name} (ID: ${plato.id})`);\n  \n  try {\n    // Preparar los datos para enviar (incluir la imagen optimizada)\n    const platoToSync = await adaptPlatoDataWithImageOptimization(plato);\n    \n    // Omitir la imagen en los logs para evitar mensajes demasiado largos\n    console.log('📤 Datos a enviar:', { \n      ...platoToSync, \n      image: platoToSync.image ? 'Imagen en base64 (omitida en log)' : null \n    });\n    \n    // Imprimir la URL exacta para depuración\n    const url = SYNC_CONFIG.platoUrl; // Usar la configuración existente\n    console.log(`🔗 URL de sincronización: ${url}`);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(platoToSync),\n      // Evitar que se incluyan cookies u otros datos de autenticación si no son necesarios\n      credentials: 'omit'\n    });\n    \n    // Verificar si la respuesta es exitosa\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`❌ Error de sincronización (${response.status}): ${errorText}`);\n      \n      // Intentar con el método de sincronización minimalista si hay un error\n      if (response.status >= 400) {\n        console.log('⚠️ Intentando sincronización minimalista como fallback...');\n        return await syncMinimalDataOnly(plato);\n      }\n      \n      return {\n        success: false,\n        message: `Error de servidor: ${response.status} ${response.statusText}`,\n        error: errorText\n      };\n    }\n    \n    // Procesar la respuesta exitosa\n    const responseData = await response.json();\n    console.log('✅ Sincronización exitosa:', responseData);\n    \n    // Actualizar el estado de sincronización en IndexedDB\n    try {\n      await updatePlatoSyncStatus(plato.id, true);\n      console.log(`✅ Estado de sincronización actualizado para plato ID: ${plato.id}`);\n    } catch (syncStatusError) {\n      console.warn(`⚠️ No se pudo actualizar el estado de sincronización: ${syncStatusError.message}`);\n    }\n    \n    return {\n      success: true,\n      message: 'Plato sincronizado correctamente',\n      data: responseData\n    };\n  } catch (error) {\n    console.error('❌ Error en sincronización:', error);\n    \n    // Intentar con el método de sincronización minimalista si hay un error\n    console.log('⚠️ Intentando sincronización minimalista como fallback...');\n    return await syncMinimalDataOnly(plato);\n  }\n};\n\n// Función para adaptar los datos del plato antes de sincronizar, con optimización de imágenes\nconst adaptPlatoDataWithImageOptimization = async (plato) => {\n  // Crear una copia para no modificar el original\n  const adaptedData = { ...plato };\n  \n  // Asegurarse de que todos los campos necesarios estén presentes\n  adaptedData.id = plato.id;\n  adaptedData.name = plato.name || 'Plato sin nombre';\n  adaptedData.price = parseFloat(plato.price) || 0;\n  adaptedData.description = plato.description || '';\n  adaptedData.category = plato.category || 'principal';\n  \n  // Optimizar la imagen si existe\n  if (plato.image && typeof plato.image === 'string' && plato.image.length > 0) {\n    try {\n      adaptedData.image = await optimizeImageForSync(plato.image);\n      console.log(`Imagen optimizada para ${plato.name}`);\n    } catch (error) {\n      console.warn(`Error al optimizar imagen para ${plato.name}:`, error);\n      adaptedData.image = plato.image; // Usar la original en caso de error\n    }\n  } else {\n    adaptedData.image = plato.image || null;\n  }\n  \n  adaptedData.image_url = plato.image_url || '';\n  adaptedData.is_available = plato.is_available !== false;\n  adaptedData.includesDrink = plato.includesDrink || false;\n  adaptedData.availableQuantity = plato.availableQuantity || 0;\n  \n  return adaptedData;\n};\n\n/**\n * Actualiza el estado de sincronización de un elemento\n * @param {string} id - ID del elemento\n * @param {string|boolean} status - Estado de sincronización ('pending', 'synced', 'pending_deletion' o un booleano)\n * @returns {Promise<boolean>} - true si se actualizó correctamente\n */\nexport async function updateSyncStatus(id, status) {\n  try {\n    // Validar que el status sea uno de los valores permitidos o convertir booleano a string\n    let validStatus = status;\n    \n    // Si es booleano, convertirlo al estado correspondiente\n    if (typeof status === 'boolean') {\n      validStatus = status === true ? 'synced' : 'pending';\n    }\n    \n    // Ahora validar que sea uno de los estados permitidos\n    if (!['pending', 'synced', 'pending_deletion'].includes(validStatus)) {\n      console.warn(`⚠️ No se pudo actualizar el estado de sincronización: Estado inválido: ${status}. Debe ser uno de: pending, synced, pending_deletion`);\n      return false;\n    }\n    \n    // Continuar con la lógica existente para actualizar el estado\n    // ...existing code...\n    \n    return true;\n  } catch (error) {\n    console.error('Error al actualizar estado de sincronización:', error);\n    return false;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}