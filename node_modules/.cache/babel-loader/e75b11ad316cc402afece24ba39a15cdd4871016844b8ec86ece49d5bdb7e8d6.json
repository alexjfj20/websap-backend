{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport { openDB } from 'idb';\nimport { v4 as uuidv4 } from 'uuid';\nimport apiConfig from '../config/apiConfig';\nconst API_BASE_URL = apiConfig.API_DOMAIN; // URL base para la API\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n\n      // Verificar que los almacenes necesarios existen\n      const storeNames = Array.from(db.objectStoreNames);\n      console.log('Almacenes disponibles:', storeNames);\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id'\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n\n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('entityType', 'entityType', {\n          unique: false\n        });\n        syncQueueStore.createIndex('entityId', 'entityId', {\n          unique: false\n        });\n        syncQueueStore.createIndex('action', 'action', {\n          unique: false\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n\n      // Crear otros almacenes necesarios\n      const requiredStores = ['businessInfo', 'categories', 'soldItems'];\n      requiredStores.forEach(storeName => {\n        if (!db.objectStoreNames.contains(storeName)) {\n          console.log(`Creando almacén ${storeName}...`);\n          db.createObjectStore(storeName, {\n            keyPath: 'id'\n          });\n          console.log(`Almacén ${storeName} creado`);\n        } else {\n          console.log(`El almacén ${storeName} ya existe`);\n        }\n      });\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDatabase = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n\n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        resolve(activePlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      request.onsuccess = event => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n\n  // Convertir booleanos a strings para compatibilidad\n  let validStatus = status;\n  if (typeof status === 'boolean') {\n    validStatus = status === true ? 'synced' : 'pending';\n    console.log(`Convertido estado booleano ${status} a \"${validStatus}\"`);\n  }\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(validStatus)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronización\n          plato.syncStatus = validStatus;\n\n          // Si es pending_deletion, marcar como no disponible también\n          if (validStatus === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${validStatus}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async id => {\n  try {\n    console.log(`Iniciando proceso de eliminación para plato ID: ${id}`);\n\n    // Verificar si estamos en línea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n\n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/api/sync/platos';\n        console.log(`URL completa para sincronización: ${serverUrl}`);\n\n        // Enviar una solicitud POST con operation=delete en lugar de DELETE\n        // Esto es más compatible con algunos servidores y proxies\n        const response = await fetch(serverUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            id: id,\n            operation: 'delete'\n          })\n        });\n\n        // Registrar detalles completos de la respuesta para depuración\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          if (response.ok) {\n            console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n\n            // Si se eliminó correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminación y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminación y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexión a internet, marcando plato ID ${id} para eliminación futura`);\n      // Si estamos offline, marcamos para eliminación y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Función para marcar un plato para eliminación\nconst markPlatoForDeletion = async id => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    return new Promise((resolve, reject) => {\n      request.onerror = event => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n\n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          getRequest.onerror = event => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          getRequest.onsuccess = event => {\n            const plato = event.target.result;\n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminación`);\n              resolve(false);\n              return;\n            }\n\n            // Marcar para eliminación\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n\n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            updateRequest.onerror = event => {\n              console.error(`Error al marcar plato ID ${id} para eliminación:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminación`));\n            };\n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminación`);\n\n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronización)\n              // Esto se hace añadiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              finalUpdateRequest.onerror = event => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacción:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminación:`, error);\n    throw error;\n  }\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  try {\n    // Validación de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    console.log('✅ Validación inicial del plato exitosa');\n\n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n\n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n\n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        request.onsuccess = async event => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n\n          // Crear objeto completo con el ID\n          const createdPlato = {\n            ...platoToCreate\n          };\n\n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n\n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n\n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        request.onerror = event => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        transaction.onerror = event => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n\n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n\n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n\n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = {\n    ...platoData\n  };\n\n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' ? parseFloat(normalizedData.price) || 0 : normalizedData.price || 0;\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n\n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n\n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n\n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && normalizedData.image.length > 200000) {\n    // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n\n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n\n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n\n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n\n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n\n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n\n  // Crear una copia para no modificar el objeto original\n  const syncPlato = {\n    ...plato\n  };\n\n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n\n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n\n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n\n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n\n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n\n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n\n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n\n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n\n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n\n    // Crear objeto mínimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n\n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n\n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificación inmediata para depuración\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = event => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async id => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\nexport { openDatabase, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato, debugIndexedDB, normalizePlatoData, guardarPlato, preparePlatoForSync, compressImageForSync, getPlato };\nexport default {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};","map":{"version":3,"names":["openDB","v4","uuidv4","apiConfig","API_BASE_URL","API_DOMAIN","DB_NAME","DB_VERSION","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","storeNames","Array","from","objectStoreNames","onupgradeneeded","contains","platosStore","createObjectStore","keyPath","createIndex","unique","syncQueueStore","autoIncrement","requiredStores","forEach","storeName","openDatabase","getAllPlatos","transaction","store","objectStore","getAll","allPlatos","length","activePlatos","filter","plato","deleted","getPendingPlatos","index","pendingPlatos","updatePlatoSyncStatus","id","status","validStatus","validStatuses","includes","Error","join","getRequest","get","syncStatus","is_available","updateRequest","put","oncomplete","close","addToSyncQueue","item","add","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","online","navigator","onLine","serverUrl","response","fetch","method","headers","body","JSON","stringify","operation","responseText","text","data","parse","ok","deleteFromIndexedDB","markPlatoForDeletion","parseError","syncError","deleteRequest","warn","updated_at","Date","toISOString","finalUpdateRequest","logDB","name","version","setInterval","verifyPlatoStorage","message","createPlato","trim","platoToCreate","createdAt","updatedAt","localTimestamp","getTime","now","Math","floor","random","createdPlato","type","entityType","entityId","timestamp","platos","found","find","p","listError","setTimeout","verified","verifyError","transactionError","debugIndexedDB","databases","window","syncQueue","stores","normalizePlatoData","platoData","normalizedData","price","parseFloat","availableQuantity","parseInt","includesDrink","image","image_thumbnail","compressImageForSync","has_local_image","imageDataUrl","startsWith","match","maxLength","actualData","substring","preparePlatoForSync","syncPlato","needsSimplification","_id","imageSize","maxImageSize","imageType","base64Data","reducedData","imageError","image_error","description","Number","Boolean","serializedSize","minimalPlato","oversized","guardarPlato","platoParaGuardar","platoGuardado","savePlato","platoToSave","savedId","savedPlato","verificationResult","getPlato","debugDB"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/indexedDBService.js"],"sourcesContent":["import { openDB } from 'idb';\nimport { v4 as uuidv4 } from 'uuid';\nimport apiConfig from '../config/apiConfig';\n\nconst API_BASE_URL = apiConfig.API_DOMAIN; // URL base para la API\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      \n      // Verificar que los almacenes necesarios existen\n      const storeNames = Array.from(db.objectStoreNames);\n      console.log('Almacenes disponibles:', storeNames);\n      \n      resolve(db);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n      \n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n        platosStore.createIndex('name', 'name', { unique: false });\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n      \n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\n        syncQueueStore.createIndex('entityType', 'entityType', { unique: false });\n        syncQueueStore.createIndex('entityId', 'entityId', { unique: false });\n        syncQueueStore.createIndex('action', 'action', { unique: false });\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n      \n      // Crear otros almacenes necesarios\n      const requiredStores = ['businessInfo', 'categories', 'soldItems'];\n      \n      requiredStores.forEach(storeName => {\n        if (!db.objectStoreNames.contains(storeName)) {\n          console.log(`Creando almacén ${storeName}...`);\n          db.createObjectStore(storeName, { keyPath: 'id' });\n          console.log(`Almacén ${storeName} creado`);\n        } else {\n          console.log(`El almacén ${storeName} ya existe`);\n        }\n      });\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDatabase = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n        \n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        \n        resolve(activePlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      \n      request.onsuccess = (event) => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n  \n  // Convertir booleanos a strings para compatibilidad\n  let validStatus = status;\n  if (typeof status === 'boolean') {\n    validStatus = status === true ? 'synced' : 'pending';\n    console.log(`Convertido estado booleano ${status} a \"${validStatus}\"`);\n  }\n  \n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(validStatus)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  \n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        \n        getRequest.onerror = (event) => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        \n        getRequest.onsuccess = (event) => {\n          const plato = event.target.result;\n          \n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n          \n          // Actualizar el estado de sincronización\n          plato.syncStatus = validStatus;\n          \n          // Si es pending_deletion, marcar como no disponible también\n          if (validStatus === 'pending_deletion') {\n            plato.is_available = false;\n          }\n          \n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          \n          updateRequest.onerror = (event) => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          \n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${validStatus}\".`);\n            resolve(true);\n          };\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async (item) => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.add(item);\n      \n      request.onsuccess = (event) => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async (id) => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.delete(id);\n      \n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async (id) => {\n  try {\n    console.log(`Iniciando proceso de eliminación para plato ID: ${id}`);\n    \n    // Verificar si estamos en línea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    \n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n        \n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/api/sync/platos';\n        console.log(`URL completa para sincronización: ${serverUrl}`);\n        \n        // Enviar una solicitud POST con operation=delete en lugar de DELETE\n        // Esto es más compatible con algunos servidores y proxies\n        const response = await fetch(serverUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            id: id,\n            operation: 'delete'\n          })\n        });\n        \n        // Registrar detalles completos de la respuesta para depuración\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          \n          if (response.ok) {\n            console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n            \n            // Si se eliminó correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminación y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminación y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexión a internet, marcando plato ID ${id} para eliminación futura`);\n      // Si estamos offline, marcamos para eliminación y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async (id) => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        const deleteRequest = platosStore.delete(id);\n        \n        deleteRequest.onerror = (event) => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        \n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Función para marcar un plato para eliminación\nconst markPlatoForDeletion = async (id) => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    return new Promise((resolve, reject) => {\n      request.onerror = (event) => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        \n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n          \n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          \n          getRequest.onerror = (event) => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          \n          getRequest.onsuccess = (event) => {\n            const plato = event.target.result;\n            \n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminación`);\n              resolve(false);\n              return;\n            }\n            \n            // Marcar para eliminación\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n            \n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            \n            updateRequest.onerror = (event) => {\n              console.error(`Error al marcar plato ID ${id} para eliminación:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminación`));\n            };\n            \n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminación`);\n              \n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronización)\n              // Esto se hace añadiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              \n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              \n              finalUpdateRequest.onerror = (event) => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          \n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacción:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminación:`, error);\n    throw error;\n  }\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async (id) => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  \n  try {\n    // Validación de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    \n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    console.log('✅ Validación inicial del plato exitosa');\n    \n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    \n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        \n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n        \n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n        \n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        \n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        \n        request.onsuccess = async (event) => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n          \n          // Crear objeto completo con el ID\n          const createdPlato = { ...platoToCreate };\n          \n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n          \n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            \n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n          \n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          \n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        \n        request.onerror = (event) => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        \n        transaction.onerror = (event) => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        \n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  \n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n    \n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n    \n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n    \n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    \n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = { ...platoData };\n  \n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' \n    ? parseFloat(normalizedData.price) || 0 \n    : (normalizedData.price || 0);\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n  \n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n  \n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n  \n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && \n      normalizedData.image.length > 200000) { // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n    \n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n    \n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  \n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n    \n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n    \n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    \n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n    \n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n    \n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  \n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n  \n  // Crear una copia para no modificar el objeto original\n  const syncPlato = { ...plato };\n  \n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n  \n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n    \n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n    \n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      \n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n            \n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            \n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n  \n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  \n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n  \n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n  \n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n  \n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n    \n    // Crear objeto mínimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    \n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  \n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  \n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    \n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n    \n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    \n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async (platoData) => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n      \n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      \n      const db = await openDB();\n      \n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n      \n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      \n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      \n      request.onsuccess = async (event) => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n        \n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = { ...platoToSave, id: savedId };\n        \n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n        \n        // Verificación inmediata para depuración\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        \n        resolve(savedPlato);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n      \n      // Manejar errores de transacción\n      transaction.onerror = (event) => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n      \n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async (id) => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\n\nexport {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  \n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};\n\nexport default {\n  openDatabase,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  \n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}