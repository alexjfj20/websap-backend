{"version":3,"file":"js/434.dd15f512.js","mappings":"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","sources":["webpack://websap/./src/services/menuService.js","webpack://websap/./node_modules/core-js/modules/es.iterator.reduce.js"],"sourcesContent":["import { getBusinessInfo, compressImage, checkItemAvailability } from './storageService';\n\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\nconst SHARED_MENU_STORE = 'sharedMenus';\nconst IMAGE_STORE = 'menuImages';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n        \n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        \n        if (!existingStores.includes(SHARED_MENU_STORE)) {\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\n          return;\n        }\n        \n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n        \n        // Crear almacén para menús compartidos si no existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.log('Creando almacén:', SHARED_MENU_STORE);\n          db.createObjectStore(SHARED_MENU_STORE, { keyPath: 'id' });\n        }\n        \n        // Crear almacén para imágenes si no existe\n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('Creando almacén:', IMAGE_STORE);\n          db.createObjectStore(IMAGE_STORE, { keyPath: 'id' });\n        }\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n/**\n * Genera un ID único para un menú\n * @returns {string} Un ID único\n */\nfunction generateMenuId() {\n  return Math.random().toString(36).substring(2, 10) + \n         Math.random().toString(36).substring(2, 10);\n}\n\n/**\n * Guarda un menú compartido y devuelve su ID\n * @param {Array} menuItems - Elementos del menú a guardar\n * @returns {Promise<String>} - ID del menú compartido\n */\nexport async function saveMenu(menuItems) {\n  try {\n    // Generar un ID único para el menú compartido\n    const menuId = generateMenuId();\n    \n    // Obtener información del negocio para incluirla en el menú compartido\n    const businessInfo = await getBusinessInfo();\n    \n    // Preprocesar los elementos del menú - comprimir imágenes y normalizar isSpecial\n    const processedItems = await Promise.all(menuItems.map(async (item) => {\n      const processedItem = { ...item };\n      processedItem.isSpecial = Boolean(item.isSpecial);\n      console.log(`[saveMenu] Guardando ${item.name} con isSpecial=${processedItem.isSpecial}`);\n      \n      // Comprimir la imagen si existe\n      if (processedItem.image && typeof processedItem.image === 'string' && processedItem.image.length > 0) {\n        try {\n          // Usar una calidad más baja para compartir\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\n        } catch (err) {\n          console.warn('Error al comprimir imagen:', err);\n          processedItem.image = null;\n        }\n      }\n      \n      return processedItem;\n    }));\n    \n    // Crear objeto del menú con información del negocio incluida\n    const menuData = {\n      id: menuId,\n      items: processedItems,\n      businessInfo: businessInfo, // Incluir la información del negocio (con datos de pago)\n      createdAt: new Date().toISOString()\n    };\n    \n    // Verificar tamaño del objeto\n    try {\n      const jsonSize = JSON.stringify(menuData).length / (1024 * 1024); // Tamaño en MB\n      console.log(`Tamaño del menú a guardar: ${jsonSize.toFixed(2)} MB`);\n      \n      if (jsonSize > 50) {\n        throw new Error(`El menú es demasiado grande (${jsonSize.toFixed(2)} MB). Reduce el tamaño de las imágenes.`);\n      }\n    } catch (error) {\n      console.error('Error al verificar tamaño del menú:', error);\n      throw new Error('Error al verificar tamaño del menú');\n    }\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú guardado exitosamente con ID: ${menuId}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Añadir logs de depuración\n    console.log('[saveMenu] Items a guardar:', menuItems.length);\n    console.log('[saveMenu] Items especiales:', menuItems.filter(item => item.isSpecial).length);\n    console.log('[saveMenu] Items regulares:', menuItems.filter(item => !item.isSpecial).length);\n    \n    // Sincronizar información del negocio con el backend\n    await syncBusinessInfoWithBackend();\n    \n    return menuId;\n  } catch (error) {\n    console.error('Error al guardar el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene un menú compartido por su ID\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getSharedMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\n    \n    // Verificar que tenemos un ID válido\n    if (!menuId) {\n      console.error('ID de menú no proporcionado');\n      return null;\n    }\n\n    // Implementación optimizada para priorizar datos en tiempo real con fallback local\n    let menuData = null;\n    let isOnline = navigator.onLine;\n    console.log(`Estado de conexión: ${isOnline ? 'Online' : 'Offline'}`);\n    \n    // Función para verificar conexión real con ping al servidor\n    const checkRealConnection = async () => {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000);\n        const response = await fetch('/api/ping', { \n          signal: controller.signal,\n          cache: 'no-store',\n          headers: { 'Cache-Control': 'no-cache' }\n        });\n        clearTimeout(timeoutId);\n        return response.ok;\n      } catch (e) {\n        console.log('Error al verificar conexión real:', e);\n        return false;\n      }\n    };\n    \n    // Intentaremos primero cargar datos en caché mientras verificamos la conexión real\n    // (Patrón stale-while-revalidate)\n    try {\n      console.log('Intentando cargar menú desde caché mientras verificamos conexión...');\n      const menuUtils = await import('./menuUtils');\n      const cachedMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n      \n      // Si tenemos un menú en caché, lo usamos temporalmente mientras obtenemos datos frescos\n      if (cachedMenu && cachedMenu.items && cachedMenu.items.length > 0) {\n        console.log('Menú en caché encontrado y listo para uso inmediato');\n        menuData = cachedMenu;\n        // Marcamos el menú como potencialmente obsoleto\n        menuData._fromCache = true;\n      }\n    } catch (cacheError) {\n      console.warn('No se pudo obtener menú en caché para uso inmediato:', cacheError);\n    }\n    \n    // Si estamos online, intentamos obtener datos frescos del servidor\n    if (isOnline) {\n      console.log(`Obteniendo menú fresco desde el servidor con ID: ${menuId}`);\n      \n      try {\n        // Comprobación real de conexión en paralelo\n        const realConnectionPromise = checkRealConnection();\n        \n        // Importamos apiService usando import dinámico para evitar problemas de dependencia circular\n        const apiService = await import('./apiService');\n        \n        // Verificamos si realmente tenemos conexión\n        const hasRealConnection = await realConnectionPromise;\n        if (!hasRealConnection) {\n          console.warn('Detectada conexión inestable o sin acceso al servidor');\n          isOnline = false;\n          // Si no tenemos conexión real pero tenemos datos en caché, usamos la caché\n          if (menuData) return menuData;\n          // De lo contrario, continuamos con el proceso de fallback\n          throw new Error('Sin conexión real al servidor');\n        }\n        \n        // Hacemos la petición al servidor para obtener el menú con timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 8000);\n        \n        const response = await Promise.race([\n          apiService.default.get(`/platos/menu/${menuId}`, { signal: controller.signal }),\n          new Promise((_, reject) => \n            setTimeout(() => reject(new Error('Timeout al obtener menú del servidor')), 8000)\n          )\n        ]);\n        \n        clearTimeout(timeoutId);\n        \n        if (response && response.success && response.data) {\n          console.log('Menú recuperado desde el servidor:', response.data);\n          menuData = response.data;\n          menuData._fromCache = false; // Marcamos como datos frescos\n          \n          // Guardar en IndexedDB para tenerlo disponible offline\n          try {\n            const menuUtils = await import('./menuUtils');\n            await menuUtils.saveMenuToIndexedDB(menuId, menuData);\n            console.log('Menú guardado en IndexedDB correctamente');\n          } catch (saveError) {\n            console.warn('No se pudo guardar el menú en IndexedDB:', saveError);\n          }\n        } else {\n          console.warn('La respuesta del servidor no contiene datos válidos:', response);\n          // Si tenemos datos en caché y la respuesta del servidor es inválida, usamos la caché\n          if (menuData && menuData._fromCache) {\n            console.log('Usando datos en caché debido a respuesta inválida del servidor');\n            return menuData;\n          }\n          // Pasamos al fallback si no tenemos caché\n        }\n      } catch (serverError) {\n        console.error('Error al obtener el menú desde el servidor:', serverError);\n        // Si hay error de conexión pero tenemos datos en caché, usamos la caché\n        if (menuData && menuData._fromCache) {\n          console.log('Usando datos en caché debido a error del servidor');\n          return menuData;\n        }\n        // Si no hay caché, pasamos al fallback completo\n        isOnline = false;\n      }\n    }\n    \n    // Si no pudimos obtener datos del servidor o estamos offline,\n    // intentamos recuperar desde IndexedDB como respaldo principal\n    if (!menuData) {\n      try {\n        console.log('Intentando recuperar menú desde IndexedDB...');\n        const menuUtils = await import('./menuUtils');\n        const localMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n        if (localMenu && localMenu.items && localMenu.items.length > 0) {\n          console.log('Menú recuperado desde IndexedDB:', localMenu);\n          menuData = localMenu;\n        } else {\n          console.warn('No se encontró el menú en IndexedDB o no contiene items');\n        }\n      } catch (localError) {\n        console.warn('No se pudo obtener el menú desde IndexedDB:', localError);\n      }\n      \n      // Si tampoco hay datos en IndexedDB, intentamos recuperar de localStorage como último recurso\n      if (!menuData) {\n        try {\n          console.log('Intentando recuperar menú desde localStorage...');\n          const cachedMenu = localStorage.getItem(`menu_${menuId}`);\n          if (cachedMenu) {\n            menuData = JSON.parse(cachedMenu);\n            console.log('Menú recuperado desde localStorage:', menuData);\n          } else {\n            throw new Error('No se encontró el menú en ninguna caché');\n          }\n        } catch (cacheError) {\n          console.error('Error al recuperar menú desde la caché:', cacheError);\n          throw new Error('No se pudo obtener el menú de ninguna fuente');\n        }\n      }\n    }\n    \n    // Si el menú no tiene información de negocio, intentar obtenerla\n    if (menuData && !menuData.businessInfo) {\n      try {\n        const businessInfo = await getBusinessInfo();\n        menuData.businessInfo = businessInfo;\n      } catch (businessError) {\n        console.warn('No se pudo obtener información del negocio:', businessError);\n        // Usar información por defecto si no se puede obtener\n        menuData.businessInfo = {\n          name: 'Restaurante WebSAP',\n          description: 'Deliciosa comida para todos los gustos',\n          contact: 'info@websap.com',\n          address: 'Calle Principal #123',\n          logo: null,\n          paymentInfo: {\n            qrImage: null,\n            qrTitle: 'Escanea para pagar',\n            nequiNumber: null,\n            nequiImage: null,\n            bankInfo: 'Banco XYZ - Cuenta 123456789',\n            otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n          }\n        };\n      }\n    }\n    \n    // Asegurarse de que businessInfo siempre tenga un objeto paymentInfo\n    if (menuData && menuData.businessInfo && !menuData.businessInfo.paymentInfo) {\n      menuData.businessInfo.paymentInfo = {\n        qrImage: null,\n        qrTitle: 'Escanea para pagar',\n        nequiNumber: null,\n        nequiImage: null,\n        bankInfo: 'Banco XYZ - Cuenta 123456789',\n        otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n      };\n    }\n    \n    // Guardar en localStorage para tener un respaldo\n    try {\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify(menuData));\n    } catch (saveError) {\n      console.warn('No se pudo guardar el menú en localStorage:', saveError);\n    }\n    \n    // Añadir logs de depuración con verificaciones de seguridad\n    console.log('[getSharedMenu] Menú recuperado:', menuData);\n    \n    // Usar el operador de encadenamiento opcional para evitar errores\n    const specialItems = menuData?.items?.filter(i => i.isSpecial) || [];\n    const regularItems = menuData?.items?.filter(i => !i.isSpecial) || [];\n    \n    console.log('[getSharedMenu] Items especiales:', specialItems.length);\n    console.log('[getSharedMenu] Items regulares:', regularItems.length);\n    \n    return menuData;\n  } catch (error) {\n    console.error('Error al obtener el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Alias para getSharedMenu para mantener compatibilidad con código existente\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getMenu(menuId) {\n  console.log('Intentando recuperar menú con ID:', menuId);\n  try {\n    const db = await openDatabase();\n    const tx = db.transaction('sharedMenus', 'readonly');\n    const store = tx.objectStore('sharedMenus');\n    \n    // Obtener el menú de la base de datos\n    const request = store.get(menuId);\n    const result = await new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        console.log('Resultado de búsqueda del menú:', request.result);\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al recuperar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Verificar si se encontró el menú\n    if (!result) {\n      console.warn(`No se encontró menú con ID: ${menuId}`);\n      return null;\n    }\n    \n    // Verificar si el menú tiene items y es un array\n    if (result && result.items && Array.isArray(result.items)) {\n      console.log('[menuService] Procesando items en getMenu()');\n      \n      // Procesar cada item para normalizar isSpecial\n      const processedItems = result.items.map(item => {\n        // Si isSpecial no existe, asignar false por defecto\n        if (item.isSpecial === undefined) {\n          console.log(`[menuService] Item ${item.name || 'sin nombre'} sin propiedad isSpecial, asignando false`);\n          return { ...item, isSpecial: false };\n        }\n        \n        // Normalizar isSpecial a un valor booleano\n        const normalizedIsSpecial = \n          item.isSpecial === true || \n          item.isSpecial === 'true' || \n          item.isSpecial === 1 || \n          item.isSpecial === '1';\n        \n        if (typeof item.isSpecial !== 'boolean') {\n          console.log(`[menuService] Normalizando isSpecial para ${item.name}: ${item.isSpecial} (${typeof item.isSpecial}) → ${normalizedIsSpecial}`);\n        }\n        \n        return { ...item, isSpecial: normalizedIsSpecial };\n      });\n      \n      console.log(`[menuService] Procesados ${processedItems.length} items:`, \n        processedItems.map(i => ({ name: i.name, isSpecial: i.isSpecial })));\n      \n      // Devolver el objeto completo con los items procesados\n      return {\n        ...result,\n        items: processedItems\n      }; // Devuelve el objeto completo con los items procesados\n    } else {\n      console.warn('El menú no tiene items o no es un array:', result);\n      \n      // Si no tiene items, devolver el resultado tal cual\n      return result;\n    }\n  } catch (error) {\n    console.error('Error al obtener menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Guarda un menú compartido en IndexedDB\n * @param {Object} menuData - Datos del menú a guardar\n * @returns {Promise<void>}\n */\nexport async function saveSharedMenu(menuData) {\n  try {\n    if (!menuData || !menuData.id) {\n      throw new Error('Datos de menú inválidos');\n    }\n    \n    console.log(`Guardando menú compartido con ID: ${menuData.id}`);\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú compartido guardado exitosamente con ID: ${menuData.id}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú compartido:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    console.log('[saveSharedMenu] Menú guardado en IndexedDB');\n    \n  } catch (error) {\n    console.error('Error al guardar el menú compartido en IndexedDB:', error);\n    throw error;\n  }\n}\n\n/**\n * Limpia menús antiguos que ya no son necesarios\n * @returns {Promise<void>}\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      \n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al obtener menús:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    \n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n    \n    console.log(`Se eliminaron ${menusToDelete.length} menús antiguos`);\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n// Añadir después de getSharedMenu\nexport async function syncMenuAvailability(menuId) {\n  try {\n    const sharedMenu = await getSharedMenu(menuId);\n    if (!sharedMenu || !sharedMenu.items) return null;\n\n    // Actualizar la disponibilidad de cada item\n    const updatedItems = await Promise.all(sharedMenu.items.map(async (item) => {\n      const availability = await checkItemAvailability(item.id);\n      return {\n        ...item,\n        availableQuantity: availability.quantity\n      };\n    }));\n\n    // Actualizar el menú con las nuevas disponibilidades\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n\n    const updatedMenu = {\n      ...sharedMenu,\n      items: updatedItems,\n      lastSync: new Date().toISOString()\n    };\n\n    await store.put(updatedMenu);\n    return updatedMenu;\n  } catch (error) {\n    console.error('Error al sincronizar disponibilidad:', error);\n    return null;\n  }\n}\n\n/**\n * Sincroniza la información del negocio con el backend\n * @param {Object} businessInfo - Información del negocio a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend(businessInfo) {\n  try {\n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n    \n    // Verificar que tenemos información válida\n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.error('No hay información del negocio para sincronizar');\n      return { success: false, message: 'No hay información del negocio para sincronizar' };\n    }\n    \n    // Importar apiService dinámicamente para evitar dependencias circulares\n    const apiServiceModule = await import('./apiService');\n    const apiService = apiServiceModule.default;\n    \n    // Asegurarse de que el token esté configurado\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return { success: false, message: 'No se pudo obtener el restaurante del usuario actual' };\n    }\n    \n    const restauranteId = userResponse.user.restaurante_id;\n    \n    // Asegurarse de que paymentInfo sea un objeto válido\n    const paymentInfo = businessInfo.paymentInfo || {\n      qrImage: null,\n      qrTitle: 'Escanea para pagar',\n      nequiNumber: null,\n      nequiImage: null,\n      bankInfo: 'Banco XYZ - Cuenta 123456789',\n      otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n    };\n    \n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name || '',\n      descripcion: businessInfo.description || '',\n      direccion: businessInfo.address || '',\n      telefono: businessInfo.contact || '',\n      logo: businessInfo.logo || null,\n      informacion_pago: JSON.stringify(paymentInfo)\n    };\n    \n    console.log('Datos a enviar al backend:', restauranteData);\n    \n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    \n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      return { success: true, message: 'Información del negocio sincronizada con éxito' };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return { success: false, message: response.message || 'Error al sincronizar información del negocio' };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return { success: false, message: error.message || 'Error al sincronizar información del negocio' };\n  }\n}\n","'use strict';\nvar $ = require('../internals/export');\nvar iterate = require('../internals/iterate');\nvar aCallable = require('../internals/a-callable');\nvar anObject = require('../internals/an-object');\nvar getIteratorDirect = require('../internals/get-iterator-direct');\n\nvar $TypeError = TypeError;\n\n// `Iterator.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-iterator.prototype.reduce\n$({ target: 'Iterator', proto: true, real: true }, {\n  reduce: function reduce(reducer /* , initialValue */) {\n    anObject(this);\n    aCallable(reducer);\n    var record = getIteratorDirect(this);\n    var noInitial = arguments.length < 2;\n    var accumulator = noInitial ? undefined : arguments[1];\n    var counter = 0;\n    iterate(record, function (value) {\n      if (noInitial) {\n        noInitial = false;\n        accumulator = value;\n      } else {\n        accumulator = reducer(accumulator, value, counter);\n      }\n      counter++;\n    }, { IS_RECORD: true });\n    if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');\n    return accumulator;\n  }\n});\n"],"names":["DB_NAME","DB_VERSION","SHARED_MENU_STORE","IMAGE_STORE","openDatabase","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","target","errorCode","onsuccess","db","result","version","existingStores","Array","from","objectStoreNames","includes","Error","onupgradeneeded","newVersion","contains","createObjectStore","keyPath","generateMenuId","Math","random","toString","substring","async","saveMenu","menuItems","menuId","businessInfo","getBusinessInfo","processedItems","all","map","processedItem","item","isSpecial","Boolean","name","image","length","compressImage","err","warn","menuData","id","items","createdAt","Date","toISOString","jsonSize","JSON","stringify","toFixed","transaction","store","objectStore","put","e","filter","syncBusinessInfoWithBackend","getSharedMenu","isOnline","navigator","onLine","checkRealConnection","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","cache","headers","clearTimeout","ok","menuUtils","cachedMenu","getMenuFromIndexedDB","_fromCache","cacheError","realConnectionPromise","apiService","hasRealConnection","race","default","get","_","success","data","saveMenuToIndexedDB","saveError","serverError","localMenu","localError","localStorage","getItem","parse","businessError","description","contact","address","logo","paymentInfo","qrImage","qrTitle","nequiNumber","nequiImage","bankInfo","otherPaymentMethods","setItem","specialItems","i","regularItems","Object","keys","message","apiServiceModule","token","setToken","userResponse","user","restaurante_id","restauranteId","restauranteData","nombre","descripcion","direccion","telefono","informacion_pago","$","iterate","aCallable","anObject","getIteratorDirect","$TypeError","TypeError","proto","real","reduce","reducer","this","record","noInitial","arguments","accumulator","undefined","counter","value","IS_RECORD"],"sourceRoot":""}